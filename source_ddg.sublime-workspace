{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Region",
				"RegionNode"
			],
			[
				"visit",
				"visited"
			],
			[
				"us",
				"unsigned"
			],
			[
				"all",
				"allPredsForRegion"
			],
			[
				"succs",
				"succsList"
			],
			[
				"succ",
				"succsList"
			],
			[
				"RegioN",
				"RegionNode"
			],
			[
				"with",
				"withinRegion"
			],
			[
				"visitReg",
				"visitRegionEnd"
			],
			[
				"node",
				"nodeCnt"
			],
			[
				"regio",
				"regionIdToNodeMap"
			],
			[
				"region",
				"regionId"
			],
			[
				"handleReg",
				"handleRegionBegin"
			],
			[
				"Regio",
				"RegionStart"
			],
			[
				"handleRe",
				"handleRegionStart"
			],
			[
				"start",
				"startRegionFn"
			],
			[
				"ddg_s",
				"ddg_start_region"
			],
			[
				"dum",
				"dump"
			],
			[
				"bod",
				"bodyList"
			],
			[
				"formal",
				"formalList"
			],
			[
				"tok",
				"TokenType"
			],
			[
				"cre",
				"createTrueAtom"
			],
			[
				"eval",
				"evalRelFns"
			],
			[
				"evala",
				"evalArithmeticFns"
			],
			[
				"create",
				"createTrueAtom"
			],
			[
				"crea",
				"createNilAtom"
			],
			[
				"evalC",
				"evalCar"
			],
			[
				"is",
				"isBound"
			],
			[
				"ret",
				"retVal"
			],
			[
				"eva",
				"evalNULL"
			],
			[
				"set",
				"setTerminalChar2"
			],
			[
				"right",
				"rightStr"
			],
			[
				"setTermi",
				"setTerminalChars"
			],
			[
				"Li",
				"LiteralAtom"
			],
			[
				"left",
				"leftStr"
			],
			[
				"termi",
				"terminalChar1"
			],
			[
				"getTok",
				"getTokenType"
			],
			[
				"dump",
				"dumpSExpStack"
			],
			[
				"getToke",
				"getTokenType"
			],
			[
				"getT",
				"getTokenStringValue"
			],
			[
				"Se",
				"SExp"
			],
			[
				"SEx",
				"SExp"
			],
			[
				"print",
				"print"
			],
			[
				"parseT",
				"parseTerminalSExp"
			],
			[
				"SE",
				"SExp"
			],
			[
				"get",
				"getTokenType"
			],
			[
				"pee",
				"peekNextToken"
			],
			[
				"getotk",
				"getTokenStringValue"
			],
			[
				"Toke",
				"TokenType"
			],
			[
				"token",
				"tokensQ"
			],
			[
				"getTer",
				"getTerminalChar2"
			],
			[
				"com",
				"compoundExp"
			],
			[
				"teri",
				"terminalChar1"
			],
			[
				"Sys",
				"System"
			],
			[
				"Output",
				"OutputStreamWriter"
			],
			[
				"toke",
				"tokensQ"
			],
			[
				"sys",
				"symStack"
			],
			[
				"sym",
				"symStack"
			],
			[
				"non",
				"nonTerminalOnTop"
			],
			[
				"symb",
				"symbList"
			],
			[
				"prod",
				"prodNumber"
			],
			[
				"Ex",
				"Exception"
			],
			[
				"T_",
				"T_OPEN_PARAN"
			],
			[
				"Tok",
				"TokenType"
			],
			[
				"S",
				"Symbol"
			],
			[
				"pu",
				"push"
			],
			[
				"T_E",
				"T_EOF"
			],
			[
				"sy",
				"symStack"
			],
			[
				"parse",
				"parseTable"
			],
			[
				"termina",
				"terminalChar"
			],
			[
				"pars",
				"parseCompoundSExp"
			],
			[
				"getTo",
				"getTokenType"
			],
			[
				"getTOke",
				"getTokenType"
			],
			[
				"le",
				"left"
			],
			[
				"term",
				"terminalChar"
			],
			[
				"Toe",
				"TokenType"
			],
			[
				"par",
				"parseTerminalSExp"
			],
			[
				"Token",
				"Token"
			],
			[
				"E",
				"Exception"
			],
			[
				"cahr",
				"charAt"
			],
			[
				"nex",
				"nextToken"
			],
			[
				"Erro",
				"ErrorString1"
			],
			[
				"char",
				"charAt"
			],
			[
				"t",
				"t	test"
			],
			[
				"TOken",
				"TokenTypes"
			],
			[
				"pri",
				"println"
			],
			[
				"read",
				"readNextSetOfToken"
			],
			[
				"tokens",
				"tokensQ"
			],
			[
				"out",
				"outputFileName"
			],
			[
				"erro",
				"errorMsg"
			],
			[
				"wor",
				"workList1"
			],
			[
				"work",
				"workList2"
			],
			[
				"wokr",
				"workList1"
			],
			[
				"add",
				"add"
			],
			[
				"getS",
				"getSuccsOf"
			],
			[
				"wo",
				"workList1"
			],
			[
				"ad",
				"addAll"
			],
			[
				"pos",
				"postOrder"
			],
			[
				"rev",
				"revPostOrder"
			],
			[
				"post",
				"postOrder"
			],
			[
				"rac",
				"reachingDefinitionsV2"
			],
			[
				"lhs",
				"lhsVar"
			],
			[
				"con",
				"containsKey"
			],
			[
				"hs",
				"hsKill"
			],
			[
				"kill",
				"killMap"
			],
			[
				"Hash",
				"HashSet"
			],
			[
				"h",
				"h"
			],
			[
				"IN",
				"Integer"
			],
			[
				"In",
				"Integer"
			],
			[
				"Jimpl",
				"JimpleBody"
			],
			[
				"o",
				"out"
			],
			[
				"new",
				"new_idom"
			],
			[
				"Unit",
				"Unit"
			],
			[
				"fin",
				"finger1"
			],
			[
				"po",
				"pOrderToUnitMap"
			],
			[
				"J",
				"JimpleBody"
			],
			[
				"entry",
				"entryNode"
			],
			[
				"unit",
				"unitColorMap"
			],
			[
				"Not",
				"NormalUnitPrinter"
			],
			[
				"ent",
				"entryNode"
			],
			[
				"gra",
				"graphDFSTraversal"
			],
			[
				"to",
				"toString"
			],
			[
				"pr",
				"println"
			],
			[
				"Node",
				"NodeColor"
			],
			[
				"mehtod",
				"methodName"
			],
			[
				"noof",
				"noofNodes"
			],
			[
				"nood",
				"noOfEdges"
			],
			[
				"no",
				"noofNodes"
			]
		]
	},
	"buffers":
	[
		{
			"file": "include/ddg/analysis/DiskCache.hxx",
			"settings":
			{
				"buffer_size": 16760,
				"line_ending": "Unix"
			}
		},
		{
			"file": "tools/reuse-analysis/include/ReadCDAG.hxx",
			"settings":
			{
				"buffer_size": 2422,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#ifndef DiskCDAG_HXX\n#define DiskCDAG_HXX\n\n//#define FULL_DAG //If defined, whole ddg is built, else just the CDAG is built\n\n#include \"ddg/analysis/LazyGraph.hxx\"\n#include \"CDAGCounter.hxx\"\n\n#include <map>\n#include <set>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <string>\n#include <iostream>\n#include <typeinfo>\n#include <sstream>\n#include <istream>\n\n#include \"ddg/analysis/DiskCache.hxx\"\n\nnamespace ddg\n{\nusing namespace llvm;\nusing namespace std;\n\n#define NUM_SLOTS 4\n\n#ifdef FULL_DAG\ntypedef size_t payload_type;\n#else\ntypedef std::set<size_t> payload_type;\n#endif\n\ntypedef unsigned char BYTE;\n\nclass DiskCDAGBuilder;\nclass DiskCDAG;\n\n// Method for calculating storage space needed to represent\n// each node by a bit.\ninline int convertNumNodesToBytes(const int &numNodes)\n{\n	// You can represent 8 nodes with a byte\n	if(numNodes % 8 == 0)\n		return int(numNodes >> 3);\n	else\n		return int(numNodes >> 3) + 1;\n}\n\nvoid dumpBitSet(BYTE *bitSet, int numSets)\n{\n	cout << \"\\n\";\n	for(int i=0;i<numSets; ++i)\n	{\n		cout << (int)bitSet[i] << \" \";\n	}\n	cout << \"\\n\";\n	cout << flush;\n}\n\nvoid setBitInBitset(BYTE *bitSet, int bitNum, int numBitSets)\n{\n	int groupIndex = bitNum >> 3;  // divide by 8\n	assert(groupIndex < numBitSets);\n	int bitIndex = bitNum % 8;\n	BYTE byteMask = 1 << (7 - bitIndex);\n	bitSet[groupIndex] = bitSet[groupIndex] | byteMask;\n}\n\nbool isBitSet(BYTE *bitSet, int bitNum, int numBitSets)\n{\n	int groupIndex = bitNum >> 3;  // divide by 8\n	assert(groupIndex < numBitSets); \n	int bitIndex = bitNum % 8;\n	BYTE byteMask = 1 << (7 - bitIndex);\n	return bitSet[groupIndex] & byteMask;\n}\n\nvoid unsetBitInBitset(BYTE *bitSet, int bitNum, int numBitSets)\n{\n	int groupIndex = bitNum >> 3;  // divide by 8\n	assert(groupIndex < numBitSets);\n	int bitIndex = bitNum % 8;\n	BYTE byteMask = ~(byteMask & 0) ^ (1 << (7 - bitIndex));\n	bitSet[groupIndex] = bitSet[groupIndex] & byteMask;\n}\n\nvoid getOnesPositionsInBitSet(BYTE *bitSet, int numBitSets, std::vector<Id> &setPos)\n{\n	BYTE zeroMask = 0;\n\n	for(unsigned int i=0; i<numBitSets; ++i)\n	{\n		if(bitSet[i] | zeroMask != 0)\n		{\n			// we have some 1's in this byte\n			for(unsigned int j=(1<<7), pos=0; j>0; j=j>>1, ++pos)\n			{\n				if(bitSet[i] & j)\n				{\n					setPos.push_back(i*8 + pos);\n				}\n			}\n		}\n	}\n}\n\nclass DiskCDAGBuilder: public LazyGraphVisitor<payload_type>\n{\n	protected:\n		DiskCDAG *cdag;\n		map<Address, size_t> loadMap; //Maps the memory address to ddg input node id\n		bool getCountsFlag;\n		Id numNodes;\n		string bcFileName;\n		fstream successorCountFile;\n\n	public:\n		DiskCDAGBuilder(DiskCDAG *cdag) :	cdag(cdag), loadMap(), \n											getCountsFlag(false), numNodes(0),\n											successorCountFile(\"\")\n		{\n\n		}\n\n		DiskCDAGBuilder() : cdag(0), loadMap(), getCountsFlag(true), \n							numNodes(0), successorCountFile(\"\")\n		{\n\n		}\n\n		DiskCDAGBuilder(string fileName) : cdag(0), loadMap(), getCountsFlag(true), \n											numNodes(0), bcFileName(fileName)\n		{\n			successorCountFile.open(string(bcFileName+\"succscounttemp\").c_str(), std::fstream::out | std::fstream::trunc);\n			successorCountFile.close();\n			successorCountFile.open(string(bcFileName+\"succscounttemp\").c_str(), std::fstream::in | std::fstream::out | std::fstream::binary);\n		}\n\n		Id getNumNodes(){return numNodes;}\n\n		virtual void visitNode(LazyNode<payload_type> *node, Predecessors	&predecessors, Operands &operands);\n		void incSuccessorCountInFile(Id nodeId);\n		size_t incNumNodesCounter();\n		void printSuccessorCountFile();\n};\n\nstruct DataList\n{\n	Id id;\n	std::vector<Id> list;\n	Id listCapacity;\n	DataList(): id(0), listCapacity(0)\n	{\n\n	}\n\n	Id getId(){return id;}\n\n	void writeToStream(fstream &file)\n	{\n		Id temp =0;\n		file.write((const char*)&id, sizeof(Id));\n		file.write((const char*)&listCapacity, sizeof(Id));\n		file.write((const char*)&list[0], sizeof(Id)*list.size());\n		for(int i=0; i<(listCapacity-list.size()); ++i)\n		{\n			file.write((const char*)&temp, sizeof(Id));\n		}\n	}\n\n	bool readNodeFromASCIIFile(istream &file)\n	{\n		listCapacity = 0;\n		file.read((char*)&id, sizeof(Id));\n		file.read((char*)&listCapacity, sizeof(Id));		\n		for(int i=0; i<listCapacity;++i)\n		{\n			Id temp =0;\n			file.read((char*)&temp, sizeof(Id));\n			if(temp > 0)\n			{\n				list.push_back(temp);\n			}\n		}\n	}\n\n	void print(ostream &out) const\n	{\n		out << \"\\n Id : \" << id;\n		out << \" ListCapacity : \" << listCapacity;\n		out << \" List (size = \" << list.size() <<\") : \";\n		for(vector<Id>::const_iterator it = list.begin();\n			it != list.end(); ++it)\n		{\n			out << *it << \" \";\n		}\n		out << flush;\n	}\n\n	void addToList(Id item)\n	{\n		if(list.size() == listCapacity)\n		{\n			cout << \"\\nError : in addToList() trying to add item : \"<< item <<\" in already full list\";\n			return;\n		}\n		list.push_back(item);\n	}\n\n	void reset()\n	{\n		id =0, listCapacity = 0, list.clear();\n	}\n\n};\nclass DiskCDAG\n{\n	private:\n		struct CDAGNode{\n			Id dynId;	// Dynamic Id \n			Address addr;	// Addresses represented by this node if any\n			unsigned int type;	// LLVM Type of the node\n			Id staticId;\n			std::vector<Id> predsList;	// Vector containing list of predecessors\n			std::vector<Id> succsList;	// Vector containing list of successors\n\n			// TODO : initialize it with proper values\n			CDAGNode(): dynId(0),\n						addr(0),\n						type(0),\n						staticId(0)\n			{\n			}\n\n			Id getId(){return dynId;}\n\n			void print(ostream &out) const\n			{\n				out << \"\\n\" << dynId << \". \";\n				out << \"Instruction :\" << llvm::Instruction::getOpcodeName(type) << \" \";\n				out << \"StaticID : \" << staticId << \" \";\n				out << \" \\n Num Predecessors: \" << predsList.size() <<\"\\n\";\n				for(std::vector<Id>::const_iterator it = predsList.begin();\n					it != predsList.end();\n					++it)\n				{\n					out << *it << \",\";\n				}\n				out << \" \\n Num Successor: \" << succsList.size() <<\"\\n\";\n				for(std::vector<Id>::const_iterator it = succsList.begin();\n					it != succsList.end();\n					++it)\n				{\n					out << *it << \",\";\n				}\n				out << \"\\n------------------------------------------------------\\n\";\n			}\n\n			// TODO : try taking in a output stream directly\n			// 		  instead of returning a string\n			void writeToStream(stringstream &ss)\n			{\n				ss.str(std::string());				\n				ss << dynId << \" \";\n				ss << staticId << \" \";\n				ss << type << \" \";\n				ss << addr << \" \";\n				ss << \"\\n\";\n				\n				ss << predsList.size() << \" \";\n				for(std::vector<Id>::iterator it = predsList.begin();\n					it != predsList.end();\n					++it)\n				{\n					ss << *it << \" \";\n				}\n				ss << \"\\n\";\n\n				ss << succsList.size() << \" \";\n				for(std::vector<Id>::iterator it = succsList.begin();\n					it != succsList.end();\n					++it)\n				{\n					ss << *it << \" \";\n				}\n				ss << \"\\n\";\n			}\n\n			void writeToStream(fstream &ss)\n			{\n\n			}\n\n			bool readNodeFromASCIIFile(istream &file)\n			{\n				\n				\n\n				// Read dynId, static Id, type and addr\n				{\n					std::string temp, line;\n					std::stringstream tempss;\n					getline(file, line);\n					tempss << line;\n					getline(tempss, temp, ' ');\n					dynId = atoi(temp.c_str());\n					getline(tempss, temp, ' ');\n					staticId = atoi(temp.c_str());\n					getline(tempss, temp, ' ');\n					type = atoi(temp.c_str());\n					getline(tempss, temp, ' ');\n					addr = atol(temp.c_str());\n				}\n\n				// Read the predecessors\n				{\n					std::string temp, line;\n					std::stringstream tempss;\n					getline(file, line);\n					tempss.str(string());\n					tempss.str(line);\n					getline(tempss, temp, ' '); // read the count\n					while(getline(tempss, temp, ' ')) // start reading the preds\n					{\n						predsList.push_back(atoi(temp.c_str()));\n					}\n				}\n\n				// Read the successors\n				{\n					std::string temp, line;\n					std::stringstream tempss;\n					getline(file, line);\n					tempss.str(string());\n					tempss.str(line);\n					getline(tempss, temp, ' '); // read the count\n					while(getline(tempss, temp, ' ')) // start reading the succs\n					{\n						succsList.push_back(atoi(temp.c_str()));\n					}		\n				}\n\n				return false; // TODO compelete this. Return true if errors\n			}\n\n			void reset()\n			{\n				dynId = 0;\n				staticId = 0;\n				addr = 0;\n				type = 0;\n				predsList.clear();\n				succsList.clear();\n			}\n		};\n\n		static const size_t CDAGNODE_SIZE = sizeof(CDAGNode);\n\n		BYTE *succsBitSet;\n		BYTE *nodeMarkerBitSet;\n		size_t numOfBytesForSuccBS;\n		size_t numOfBytesFornodeMarkerBitSet;\n\n\n		size_t blockSize;\n		size_t blockCount;\n		size_t curBlockSize;\n\n		std::map<Id, CDAGNode*> idToCDAGNodeMap;\n\n		fstream graphDumpFile;\n		fstream succsListTempFile;\n		fstream succsListNewTempFile;\n\n		// TODO : Temp ofstreams - remove these!\n		ofstream printBeforeWriteFile;\n		ofstream printAfterReadFile;\n\n		size_t numNodes; //No. of nodes created so far\n		size_t count; //Total expected no. of nodes\n\n		// FileNames\n		const string bcFileName;\n		string diskGraphFileName;\n		string diskGraphIndexFileName;\n\n		DiskCache<DataList, Id> *succsCache;\n\n		void init(size_t count)\n		{\n			diskGraphFileName = string(bcFileName+\"diskgraph\");\n			diskGraphIndexFileName = string(bcFileName+\"diskgraph_index\");\n\n			numOfBytesForSuccBS = convertNumNodesToBytes(count);\n			cout << \"\\ncount :\" <<count;\n			cout << \"\\n numOfBytesForSuccBS: \" <<numOfBytesForSuccBS;\n			succsBitSet = new BYTE[numOfBytesForSuccBS];\n			nodeMarkerBitSet = 0; // to be initialized if we get actual node count\n			memset(succsBitSet, 0, numOfBytesForSuccBS);\n\n			cout << \"\\nSize of succsBitSet \" << sizeof(BYTE);\n\n			// TODO : compare with CDAGNODE_WITHSUCC_SIZE\n			if(blockSize != 0 && blockSize < CDAGNODE_SIZE)\n				cout << \"\\n Block size is less than CDAG node size..Aborting!\";\n			else if(blockSize == 0){\n				cout << \"\\n Block size is passed as zero - memory based graph will be generated.\";\n			}\n\n\n			//  TODO : revisit this part for checking corner cases and add some comments\n			graphDumpFile.open(string(bcFileName+\"graphdump\").c_str(), std::fstream::out | std::fstream::trunc);\n			graphDumpFile.close();\n			graphDumpFile.open(string(bcFileName+\"graphdump\").c_str(), std::fstream::in | std::fstream::out);\n			\n			succsListTempFile.open(string(bcFileName+\"succslisttemp\").c_str(), std::fstream::out | std::fstream::trunc);\n			succsListTempFile.close();\n			succsListTempFile.open(string(bcFileName+\"succslisttemp\").c_str(), std::fstream::in | std::fstream::out | std::fstream::binary);\n\n			succsListNewTempFile.open(string(bcFileName+\"succslistnewtemp\").c_str(), std::fstream::out | std::fstream::trunc);\n			succsListNewTempFile.close();\n			succsListNewTempFile.open(string(bcFileName+\"succslistnewtemp\").c_str(), std::fstream::in | std::fstream::out | std::fstream::binary);\n			\n			printBeforeWriteFile.open(string(bcFileName+\"printbeforewrite\").c_str());\n			printAfterReadFile.open(string(bcFileName+\"printafterread\").c_str());\n\n			// // dumping blocks of memory to the file\n			// cout <<\"\\n Dumping blockss for succesor file\" <<flush;\n			// for(int i=0; i < count; ++i)\n			// {\n			// 	succsListTempFile.write((const char*)&succsBitSet[0], numOfBytesForSuccBS*sizeof(BYTE));\n			// }\n			// cout << \"\\n Done creating the successor file\" <<flush;\n\n			// initialize the new successor list file\n			initSuccessorListFile();\n\n			succsCache = new DiskCache<DataList, Id>(512, 2, true);\n			if(!succsCache->init(bcFileName+\"succslistnewtemp\"))\n			{\n				cout << \"\\n Cache initialization for successor's list failed...\";\n				return;\n			}\n			// cout << \"\\n Printing succs list from cache\";\n			// cin.get();\n			// for(int i=0; i<count; ++i)\n			// {\n			// 	DataList* l = succsCache->getData(i);\n			// 	l->print(cout);\n			// }\n		}\n\n		void initSuccessorListFile()\n		{\n			fstream succsCountTempFile;\n			string succsCountTempFileName = bcFileName+\"succscounttemp\";\n			succsCountTempFile.open(succsCountTempFileName.c_str(), std::fstream::in | std::fstream::out | std::fstream::binary);\n			succsCountTempFile.seekg(0, ios::beg);\n			Id succCount =0;\n			Id id = 0;\n			Id temp = 0;\n			while(!succsCountTempFile.read((char*)&succCount, sizeof(Id)).eof())\n			{\n				succsListNewTempFile.write((const char*)&id, sizeof(Id));\n				succsListNewTempFile.write((const char*)&succCount, sizeof(Id));\n				for(int i=0; i<succCount; ++i)\n				{\n					succsListNewTempFile.write((const char*)&temp, sizeof(Id));\n				}\n				++id;\n			}\n			succsListNewTempFile.close();\n\n			// Delete the temp count file\n			remove(succsCountTempFileName.c_str());\n\n			// // TODO : Test code\n			// {\n			// 	DiskCache<DataList, Id> succsCache(blockSize, 2, true);\n			// 	if(!succsCache.init(bcFileName+\"succslistnewtemp\"))\n			// 	{\n			// 		cout << \"\\n Cache initialization for successor's list failed...\";\n			// 		return;\n			// 	}\n			// 	cout << \"\\n Printing succs list from cache\";\n			// 	cin.get();\n			// 	for(int i=0; i<count; ++i)\n			// 	{\n			// 		DataList* l = succsCache.getData(i);\n			// 		l->print(cout);\n			// 	}\n			// 	DataList* l = succsCache.getData(1610);\n			// 	l->print(cout);\n			// 	l->addToList(5);\n			// 	l = succsCache.getData(1610);\n			// 	l->print(cout);\n			// }\n			// cin.get();\n\n			// {\n			// 	DiskCache<DataList, Id> succsCache(blockSize, 2);\n			// 	cin.get();\n			// 	if(!succsCache.init(bcFileName+\"succslistnewtemp\"))\n			// 	{\n			// 		cout << \"\\n Cache initialization for successor's list failed...\";\n			// 		return;\n			// 	}\n			// 	for(int i=0; i<count; ++i)\n			// 	{\n			// 		DataList* l = succsCache.getData(i);\n			// 		l->print(cout);\n			// 	}\n			// 	cout << \" \\n\\n Testing Write back to file\";\n			// 	DataList* l = succsCache.getData(1610);\n			// 	l->print(cout);\n			// }\n\n			// cin.get();\n		}\n\n	public:\n		DiskCDAG(size_t count) : numNodes(0),\n								 count(count),\n								 blockSize(0),\n								 blockCount(0),\n								 curBlockSize(0)\n		{\n			init(count);\n		}\n\n		DiskCDAG(Ids &ids, const string &bcFile, \n			size_t bs, Id nodeCount) : numNodes(0),\n									 	blockSize(bs*1024), // block size is passed in MB\n									 	//blockSize(bs),\n									 	blockCount(0),\n									 	curBlockSize(0),\n									 	bcFileName(bcFile),\n									 	count(nodeCount)\n		{\n			cout << \"\\n Size of CDAGNode \" << sizeof(CDAGNode);\n			//CDAGCounter counter(ids); //Get the count of expected no. of nodes\n			//count = counter.getCount();\n			init(count);\n		}\n\n		~DiskCDAG()\n		{\n			delete []succsBitSet;\n\n			if(nodeMarkerBitSet)\n			{\n				delete []nodeMarkerBitSet;\n			}\n\n			// delete the graph nodes and clean up the maps\n			std::map<Id, CDAGNode*>::iterator it1 = idToCDAGNodeMap.begin();\n			for(; it1 != idToCDAGNodeMap.end(); ++it1)\n			{\n				delete it1->second;\n			}\n			idToCDAGNodeMap.clear();\n\n			if(succsCache)\n			{\n				delete succsCache;\n			}\n		}\n\n		//Returns the no. of nodes in the cdag\n		size_t getNumNodes()\n		{\n			return numNodes;\n		}\n\n		//Adds a node to the cdag with instruction type 'currType' and static id 'id'\n		size_t addNode(unsigned int currType, size_t id, Address addr)\n		{\n			assert(numNodes < count);\n\n			CDAGNode *node = new CDAGNode();\n			node->dynId = numNodes;\n			node->type = currType;\n			node->staticId = id;\n			if(currType == Instruction::Load){\n				// addr is only consumed in case of load instruction\n				node->addr = addr;\n			}\n\n			addUpdateNodeToBlock(node);\n\n			//node->blockId = blockCount; // this will be updated by addUpdateNodeToBlock\n			//idToCDAGNodeMap[node->dynId] = node;\n\n			return numNodes++;\n		}\n\n		void setPredecessor(size_t nodeId, const set<size_t> &predSet)\n		{\n			assert(nodeId < numNodes);\n			size_t size = predSet.size();\n			set<size_t>::const_iterator it = predSet.begin();\n			for(size_t i=0; i<size; ++i)\n			{\n				idToCDAGNodeMap[nodeId]->predsList.push_back(*it);\n				//writeSuccessorInFile((*it), nodeId);\n				//updateSuccessorCountInFile((*it), 1); // bump up the count by 1\n				DataList *l = succsCache->getData((*it));\n				l->addToList(nodeId);\n				++it;\n			}\n\n			addUpdateNodeToBlock(idToCDAGNodeMap[nodeId]);\n		}\n		\n		// Mark a node\n		void markNode(Id nodeId)\n		{\n			if(!nodeMarkerBitSet)\n			{\n				numOfBytesFornodeMarkerBitSet = convertNumNodesToBytes(numNodes);\n				nodeMarkerBitSet = new BYTE[numOfBytesFornodeMarkerBitSet];\n				memset(nodeMarkerBitSet, 0, numOfBytesFornodeMarkerBitSet); // unmark all the node by default\n			}\n			setBitInBitset(nodeMarkerBitSet, nodeId, numOfBytesFornodeMarkerBitSet);\n		}\n\n		// Unmark a node\n		void unmarkNode(Id nodeId)\n		{\n			if(!nodeMarkerBitSet)\n			{\n				numOfBytesFornodeMarkerBitSet = convertNumNodesToBytes(numNodes);\n				nodeMarkerBitSet = new BYTE[numOfBytesFornodeMarkerBitSet];\n				memset(nodeMarkerBitSet, 0, numOfBytesFornodeMarkerBitSet); // unmark all the node by default\n				return;\n			}\n			unsetBitInBitset(nodeMarkerBitSet, nodeId, numOfBytesFornodeMarkerBitSet);\n		}\n\n		// Unmark all the nodes\n		void unmarkAllNodes()\n		{\n			if(!nodeMarkerBitSet)\n			{\n				numOfBytesFornodeMarkerBitSet = convertNumNodesToBytes(numNodes);\n				nodeMarkerBitSet = new BYTE[numOfBytesFornodeMarkerBitSet];\n			}\n			memset(nodeMarkerBitSet, 0, numOfBytesFornodeMarkerBitSet);\n		}\n\n		// Is node marked/unmarked\n		bool isNodeMarked(const Id &nodeId)\n		{\n			return isBitSet(nodeMarkerBitSet, nodeId, numOfBytesFornodeMarkerBitSet);\n		}\n\n		// Finds the first unmarked node (i.e. the first 0 in bitset)\n		// If there is a node it returns true\n		// Otherwise false. \n		bool getFirstReadyNode(Id &nodeId)\n		{\n			bool retVal = false;\n			BYTE oneMask = ~0;\n			for(unsigned int i=0; i<numOfBytesFornodeMarkerBitSet; ++i)\n			{\n				if(nodeMarkerBitSet[i] ^ oneMask != 0)\n				{\n					// we have zero in here somewhere\n					for(unsigned int j=(1<<7), pos=0; j>0; j=j>>1, ++pos)\n					{\n						if((nodeMarkerBitSet[i] & j) == 0)\n						{\n							nodeId = i*8 + pos;\n							retVal = true;\n							break;\n						}\n					}\n				}\n				if(retVal)\n					break; // node found so break;\n			}\n			if(nodeId >= numNodes) // is there a better way to handle this?\n				retVal = false;\n			return retVal;\n		}\n\n		// void updateSuccessorCountInFile(Id nodeId, Id incCount)\n		// {\n		// 	streampos pos(sizeof(Id)*nodeId);\n		// 	succsCountTempFile.seekg(pos, ios::beg);\n		// 	Id curVal = 0;\n		// 	succsCountTempFile.read((char*)&curVal, sizeof(Id));\n\n		// 	curVal += incCount;\n\n		// 	succsCountTempFile.seekg(pos, ios::beg);\n		// 	succsCountTempFile.write((const char*)&curVal, sizeof(Id));\n		// }\n\n		void writeSuccessorInFile(int parentNodeId, int childNodeId)\n		{\n			// Start by getting the successor bitset for parent node\n			streampos pos((numOfBytesForSuccBS*sizeof(BYTE)) * parentNodeId);\n			succsListTempFile.seekg(pos, ios::beg);\n			succsListTempFile.read((char*)&succsBitSet[0], numOfBytesForSuccBS*sizeof(BYTE));\n\n			// Update the bitset vector with the childNodeId\n			setBitInBitset(succsBitSet, childNodeId, numOfBytesForSuccBS);\n\n			// Write back the updated successor list to the file\n			succsListTempFile.seekp(pos, ios::beg);\n			succsListTempFile.write((const char*)&succsBitSet[0], numOfBytesForSuccBS*sizeof(BYTE));\n		}\n\n		void readSuccessorsFromFile(int nodeId, std::vector<Id> &succsList)\n		{\n			succsList.clear();\n			// Get to the node in the file\n			streampos pos((numOfBytesForSuccBS*sizeof(BYTE)) * nodeId);\n			succsListTempFile.seekg(pos, ios::beg);\n\n			// Read the successor bitset from the file\n			succsListTempFile.read((char*)&succsBitSet[0], numOfBytesForSuccBS*sizeof(BYTE));\n\n			// fill in the result vector\n			getOnesPositionsInBitSet(succsBitSet, numOfBytesForSuccBS, succsList);\n		}\n\n		void updateGraphWithSuccessorInfo()\n		{\n			cout << \"\\n In updateGraphWithSuccessorInfo\";\n			ofstream diskGraph(diskGraphFileName.c_str());\n			ofstream diskGraphIndex(diskGraphIndexFileName.c_str(), ios::binary);\n\n			streampos pos(0);\n			size_t curBlockSize = 0;\n			size_t bs = blockSize*NUM_SLOTS;\n\n			graphDumpFile.clear();\n	 		graphDumpFile.seekg(0, ios::beg);\n	 		blockCount = 0;\n\n	 		cout << \"\\n Starting to write the final graph\";\n	 		//cin.get();\n\n			while(!readBlockFromFile(graphDumpFile))\n			{\n				writeGraphWithSuccessorInfoToFile(diskGraph, diskGraphIndex, \n					blockSize, pos, curBlockSize);\n				++blockCount;\n			}\n\n			writeGraphWithSuccessorInfoToFile(diskGraph, diskGraphIndex,\n			 blockSize, pos, curBlockSize);\n			diskGraph.close();\n			diskGraphIndex.close();\n\n			cout << \"\\n Done writing the disk graph\";\n\n			delete succsCache;\n		}\n\n		void writeGraphWithSuccessorInfoToFile(ofstream &diskGraph,\n											   ofstream &diskGraphIndex,\n											   size_t bs,\n											   streampos &pos,\n											   size_t &curBlockSize)\n		{\n			\n			vector<CDAGNode*> nodesToWriteList;\n			vector<Id> succList;\n			stringstream ss;\n\n			map<Id, CDAGNode*>::iterator it = idToCDAGNodeMap.begin();\n			for(; it != idToCDAGNodeMap.end(); ++it)\n			{\n				//readSuccessorsFromFile(it->first, succList);\n				succList.clear(); // optimization : use a pointer to the vector\n				DataList * l = succsCache->getData(it->first);\n				CDAGNode *curNode = it->second;\n				if(l->list.size() > 0)\n				{\n					curNode->succsList = l->list;\n				}\n\n				// Check if we reached the write block size\n				size_t curNodeSize = sizeof(*curNode);\n				if(curBlockSize + curNodeSize > bs)\n				{\n					// dump out nodesToWriteList\n					vector<CDAGNode*>::iterator it1 = nodesToWriteList.begin();\n					for(; it1 != nodesToWriteList.end(); ++it1)\n					{\n						(*it1)->writeToStream(ss);\n						diskGraph << ss.str();\n						//diskGraphIndex.write((const char*)&pos, sizeof(streampos));\n					}\n					pos = diskGraph.tellp();\n					\n					// reset the variables\n					nodesToWriteList.clear();\n					curBlockSize = 0;\n				}	\n				curBlockSize += curNodeSize;\n				nodesToWriteList.push_back(curNode);					\n			}\n\n			// dump out any remaining nodes\n			if(nodesToWriteList.size() > 0)\n			{\n				vector<CDAGNode*>::iterator it1 = nodesToWriteList.begin();\n				for(; it1 != nodesToWriteList.end(); ++it1)\n				{\n					(*it1)->writeToStream(ss);\n					diskGraph << ss.str();\n					//diskGraphIndex.write((const char*)&pos, sizeof(streampos));\n				}\n			}\n		}\n\n		//Generates the DiskCDAG using DiskCDAGBuilder\n		static DiskCDAG* generateGraph(Ids& ids, const string &bcFileName, int block_size)\n		{\n			cout <<\"\\n First pass through trace to get counts\" << flush;\n			DiskCDAGBuilder countBuilder(bcFileName);\n			countBuilder.visit(ids);\n			cout <<\"\\n Pass complete. Number of nodes : \"<<countBuilder.getNumNodes() << flush;\n			//countBuilder.printSuccessorCountFile();\n			//cin.get();\n\n			DiskCDAG *cdag = new DiskCDAG(ids, bcFileName, \n				block_size, countBuilder.getNumNodes());\n\n			cout << \"\\n Writing graphdump now!\"<<flush;\n			DiskCDAGBuilder builder(cdag);\n			builder.visit(ids);\n			cout << \"\\n Done writing graphdump now!\" <<flush;\n\n			return cdag;\n		}\n\n		//Generates the DiskCDAG using user-specified 'Builder'\n		template <typename Builder>\n			static DiskCDAG* generateGraph(Ids& ids, string &bcFileName, int block_size)\n			{\n				cout <<\"\\n First pass through trace to get counts\" << flush;\n				DiskCDAGBuilder countBuilder(bcFileName);\n				countBuilder.visit(ids);\n				cout <<\"\\n Pass complete. Number of nodes : \"<<countBuilder.getNumNodes() << flush;\n				//countBuilder.printSuccessorCountFile();\n\n				DiskCDAG *cdag = new DiskCDAG(ids, bcFileName, \n				block_size, countBuilder.getNumNodes());\n\n				cout << \"\\n Writing graphdump now!\"<<flush;\n				Builder builder(cdag);\n\n				builder.visit(ids);\n				cout << \"\\n Done writing graphdump now!\" <<flush;\n\n				return cdag;\n			}\n\n		void performBFS()\n		{\n			cout << \"\\n Starting BFS on graph with \" << numNodes << \" nodes.\";\n\n			cout << \"\\n Initialize LRU cache\";\n\n			DiskCache<CDAGNode, Id> *lruCache = new DiskCache<CDAGNode, Id>(blockSize, NUM_SLOTS);\n			//if(!lruCache->init(diskGraphFileName, diskGraphIndexFileName ))\n			if(!lruCache->init(diskGraphFileName))\n			{\n				cout <<\"\\n Cache initialization failed..stopping BFS\";\n				return;\n			}\n			cout << \"\\n LRU Disk Cache initialized.\";\n\n			unmarkAllNodes(); // mark all nodes as ready\n			queue<Id> q;\n			Id startV;\n			vector<Id> bfsOutput;\n			bool error = false;\n			while(getFirstReadyNode(startV))\n			{\n				cout << \"\\n Starting vertex :\" <<startV;\n				q.push(startV);\n				markNode(startV);			\n				while(!q.empty())\n				{\n					const CDAGNode *curNode = lruCache->getData(q.front());\n					if(!curNode)\n					{\n						cout <<\"\\n Failed to get \" << q.front() << \" node..stopping BFS\";\n						error = true;\n						break;\n					}\n					q.pop();\n					//cout << curNode->dynId << \" \";\n					bfsOutput.push_back(curNode->dynId);\n					for(vector<Id>::const_iterator it = curNode->succsList.begin();\n						it != curNode->succsList.end(); ++it)\n					{\n						if(!isNodeMarked(*it))\n						{\n							q.push(*it);\n							markNode(*it);	\n						}\n						else\n						{\n							// its already visited\n						}\n					}\n				}\n				cout << \"\\n Listing reachable nodes in BFS order : \\n\";\n				for(vector<Id>::iterator it = bfsOutput.begin(); \n					it != bfsOutput.end(); ++it)\n				{\n					cout << *it << \" \";\n				}\n				cout <<\"\\n\";\n				bfsOutput.clear();\n				if(error)\n					break;\n			}\n\n			delete lruCache;\n		}\n\n	 	void printDiskGraph(ostream &out)\n	 	{\n	 		std::map<Id, CDAGNode*>::iterator it = idToCDAGNodeMap.begin();\n	 		//cout <<\"\\n\\n \" ;\n	 		for(; it!=idToCDAGNodeMap.end(); ++it)\n	 		{\n	 			it->second->print(out);\n	 		}\n	 	}\n\n		//Prints the graph in dot format\n		void printDOTGraph(const char *filename)\n		{\n			// ofstream file;\n			// file.open(filename);\n			// file << \"digraph \\\"ddg\\\" {\\n\";\n\n			// for(size_t i=0; i<numNodes; i++)\n			// {\n			// 	file << \"\\tNode\" << i << \" [label=\\\"\" << i << \". \" << llvm::Instruction::getOpcodeName(type[i]) << \"\\\"];\\n\";\n			// 	size_t numPreds = predCnt[i];\n			// 	for(size_t j=0; j<numPreds; j++)\n			// 	{\n			// 		file << \"\\tNode\" << predList[i][j] << \" -> Node\" << i << \";\\n\";\n			// 	}\n			// }\n\n			// file << \"}\";\n			// file.close();\n		}\n\n		//Prints the graph in YAML format\n		void printYAMLGraph(const char *filename)\n		{\n			// ofstream file;\n			// file.open(filename);\n\n			// file << \"Nodes: \\n\";\n			// for(size_t i=0; i<numNodes; ++i)\n			// {\n			// 	file << \"  \" << i << \": {null: 0}\\n\";\n			// }\n			// file << \"Edges: \\n\";\n			// for(size_t i=0; i<numNodes; ++i)\n			// {\n			// 	size_t numScsrs = scsrCnt[i];\n			// 	if(numScsrs == 0)\n			// 		continue;\n			// 	file << \"  \" << i << \": {\";\n			// 	for(size_t j=0; j<numScsrs-1; ++j)\n			// 	{\n			// 		file << scsrList[i][j] << \": 1, \";\n			// 	}\n			// 	file << scsrList[i][numScsrs-1] << \": 1}\\n\";\n			// }\n			// file.close();\n		}\n\n		// Disk CDAG block management\n\n		void flushCurrentBlockToDisk(bool flag)\n		{\n			//printDiskGraph(printBeforeWriteFile);\n\n			cout <<\"\\n Flushing current block to disk\\n\";\n\n			std::map<Id, CDAGNode*>::iterator it = idToCDAGNodeMap.begin();\n	 		stringstream ss;\n	 		for(; it!=idToCDAGNodeMap.end(); ++it)\n	 		{\n	 			it->second->writeToStream(ss);\n	 			graphDumpFile << ss.str();\n	 		}\n	 		graphDumpFile.flush();\n\n	 		// reset all the required variables after flushing to\n			// disk\n			resetGraphState();\n\n\n	 		// TODO : test code for checking read of blocks - to remove\n	 		// if(flag)\n	 		// {\n	 		// 	// last flush to disk \n	 		// 	graphDumpFile.clear();\n	 		// 	graphDumpFile.seekg(0, ios::beg);\n	 		// 	blockCount = 0;\n	 		// 	while(!readBlockFromFile(graphDumpFile))\n	 		// 	{\n	 		// 		printDiskGraph(printAfterReadFile);\n	 		// 		++blockCount;\n	 		// 	}\n	 		// 	printDiskGraph(printAfterReadFile);\n	 		// }\n		}\n\n		// Reads a block from a given stream to the \n		// in memory map\n		bool readBlockFromFile(istream &file)\n		{\n			cout << \"\\n\\n In readBlockFromFile \\n\";\n			bool err = true;\n			resetGraphState();\n\n			streampos pos;\n			while(!file.eof())\n			{\n				pos = file.tellg();\n				CDAGNode *node = new CDAGNode();\n				err = node->readNodeFromASCIIFile(file);\n				curBlockSize += sizeof(*node);\n				if(curBlockSize < blockSize*NUM_SLOTS && !file.eof())\n				{\n					idToCDAGNodeMap[node->dynId] = node;\n				}\n				else\n				{\n					// we have read an extra node move back \n					// if we have not reached the end of file\n					// yet\n					if(!file.eof())\n					{\n						file.seekg(pos, ios::beg);\n					}\n					break; //we have read the block\n				}\n			}\n			cout << \"\\n Exiting readBlockFromFile method with return value \" << (err || file.eof())<< \"\\n\\n\";\n\n			return (err || file.eof()); // return true if error or eof is reached\n		}\n\n\n	private:\n		unsigned int addUpdateNodeToBlock(CDAGNode *node){\n			// Check if user specified a block size.\n			// If not then its a in memory CDAG.\n			// just return.\n			if(blockSize == 0)\n			{\n				idToCDAGNodeMap[node->dynId] = node; // just update the map\n				return blockCount;\n			}\n\n			size_t nodeSize = sizeof(*node);\n			assert(nodeSize > 0);\n\n			Id nodeId = node->dynId;\n\n			if(idToCDAGNodeMap.find(nodeId) != idToCDAGNodeMap.end())\n			{\n				// this is an existing node which is being updated\n				if(nodeSize > CDAGNODE_SIZE)\n				{\n					// if the size of this node has grown bigger than the \n					// initial node size then just count the extra size by\n					// which the node has grown\n					nodeSize = nodeSize - CDAGNODE_SIZE;\n					//continue\n				}\n				else\n				{\n					// Allocated space is enough. No block updates required.\n					return blockCount;\n				}\n\n			}\n			else\n			{\n				// this is a new node being added\n				// continue.\n			}\n\n			// If we have reached here then either : \n			// A new node is being added\n			// Or an existing node has grown in size.\n\n			int newBlockSize = curBlockSize + nodeSize;\n\n			if(newBlockSize < blockSize)\n			{\n				// if updated block size < current block size\n				// then no change is needed\n				curBlockSize = newBlockSize;\n			}\n			else\n			{\n				// we have exceeded the specified block size\n\n				// check if we had partially created this node\n				// in the current block. This is a \"spill node\"\n				// which is partially extending to next block as well.\n\n				// If yes then we need to remove this node before\n				// flushing the map out to disk.\n				if(idToCDAGNodeMap.find(nodeId) != idToCDAGNodeMap.end())\n				{\n					idToCDAGNodeMap.erase(nodeId);\n				}\n				else\n				{\n					// this is a brand new node\n				}\n\n				// flush the current block to the disk\n				flushCurrentBlockToDisk(false);\n\n				// start using a new block now\n				++blockCount;\n\n				// update curBlockSize\n				curBlockSize = sizeof(*node);\n			}\n			idToCDAGNodeMap[nodeId] =  node;\n\n			return blockCount;\n		}\n\n\n		void resetGraphState()\n		{\n			// TODO : try and create a CDAGNode pool instead of deleting the\n			//		  nodes everytime.\n			std::map<Id, CDAGNode*>::iterator it = idToCDAGNodeMap.begin();\n			for(; it!=idToCDAGNodeMap.end(); ++it)\n			{\n				delete it->second;\n			}\n\n			idToCDAGNodeMap.clear();\n			curBlockSize = 0;\n		}\n\n	public:\n		// Other API  : NOT YET IMPLEMENTED\n		//Returns the successor list of 'nodeId'\n		void getSuccessors(size_t nodeId, const size_t *&list, size_t &size)\n		{\n			assert(nodeId < numNodes);\n		}\n\n		//Returns the predecessor list of 'nodeId'\n		void getPredecessors(size_t nodeId, const size_t *&list, size_t &size)\n		{\n			assert(nodeId < numNodes);\n		}\n\n		//Returns no. of successors of 'nodeId'\n		size_t getNumSuccessors(size_t nodeId)\n		{\n			assert(nodeId < numNodes);\n		}\n\n		//Returns no. of predecessors of 'nodeId'\n		size_t getNumPredecessors(size_t nodeId)\n		{\n			assert(nodeId < numNodes);\n		}\n\n\n		//Returns True if 'nodeId' is input node, false otherwise\n		bool isInputNode(size_t nodeId)\n		{\n		\n		}\n\n		//Returns True if 'nodeId' is output node, false otherwise\n		bool isOutputNode(size_t nodeId)\n		{\n			\n		}\n};\n\n#ifdef FULL_DAG\nvoid DiskCDAGBuilder::visitNode(LazyNode<payload_type> *node, Predecessors &predecessors, Operands &operands)\n{\n	set<size_t> predSet;\n	Instruction *instr = node->getInstruction();\n\n	//In case of LoadInst, check if we need to create an edge from input node\n	if(isa<LoadInst>(instr))\n	{\n		bool flag = true;\n		for(Predecessors::iterator pred = predecessors.begin(), predEnd =	predecessors.end(); pred != predEnd;	++pred)\n		{\n			if(isa<StoreInst>((*pred)->getInstruction()))\n			{\n				flag = false;\n				break;\n			}\n		}\n		if(flag == true)\n		{\n			//Check if a cdag node with the same address has been already created. If so, do nothing; else create a new input node.\n			Address addr = node->getAddress();\n			std::map<Address, size_t>::const_iterator it = loadMap.find(addr);\n			size_t tempId;\n			if(it == loadMap.end())\n			{\n				size_t inputNodeId = cdag ? cdag->addNode(Instruction::Load, \n					cast<ConstantInt>(instr->getMetadata(\"id\")->getOperand(0))->getZExtValue(),\n					addr) : incNumNodesCounter();\n				loadMap.insert(make_pair(addr, inputNodeId));\n				tempId = inputNodeId;\n			}\n			else\n			{\n				tempId = it->second;\n			}\n			predSet.insert(tempId);\n			if(successorCountFile)\n			{\n				// we are writing successor count to file\n				incSuccessorCountInFile(tempId);\n			}\n		}\n	}\n\n	//Create a cdag node\n	size_t nodeId = cdag ? cdag->addNode(instr->getOpcode(),\n		cast<ConstantInt>(instr->getMetadata(\"id\")->getOperand(0))->getZExtValue(),\n		0) : incNumNodesCounter();\n	for(Predecessors::iterator pred = predecessors.begin(), predEnd =	predecessors.end(); pred != predEnd;	++pred)\n	{\n		payload_type pred_data = (*pred)->get();\n		predSet.insert(pred_data);\n		if(successorCountFile)\n		{\n			// we are writing successor count to file\n			incSuccessorCountInFile(pred_data);\n		}\n	}\n	if(cdag) cdag->setPredecessor(nodeId, predSet);\n	node->set(nodeId);\n}\n#else\nvoid DiskCDAGBuilder::visitNode(LazyNode<payload_type> *node, Predecessors &predecessors, Operands &operands)\n{\n	set<size_t> predSet;\n	Instruction *instr = node->getInstruction();\n\n	//In case of LoadInst, check if we need to create an input node.\n	if(isa<LoadInst>(instr))\n	{\n		bool flag = true; //false if the load is preceded by a store.\n		for(Predecessors::iterator pred = predecessors.begin(), predEnd =	predecessors.end(); pred != predEnd;	++pred)\n		{\n			if(isa<StoreInst>((*pred)->getInstruction()))\n			{\n				flag = false;\n				break;\n			}\n		}\n		if(flag == true)\n		{\n			//Check if a cdag node with the same address has been already created. If so, do nothing; else create a new input node.\n			Address addr = node->getAddress();\n			std::map<Address, size_t>::const_iterator it = loadMap.find(addr);\n			size_t tempId;\n			if(it == loadMap.end())\n			{\n				size_t inputNodeId = cdag ? cdag->addNode(Instruction::Load, \n					cast<ConstantInt>(instr->getMetadata(\"id\")->getOperand(0))->getZExtValue(),\n					addr) : incNumNodesCounter();\n				loadMap.insert(make_pair(addr, inputNodeId));\n				tempId = inputNodeId;\n			}\n			else\n			{\n				tempId = it->second;\n			}\n			node->get().clear();\n			node->get().insert(tempId);\n			return;\n		}\n	}\n\n	if(instr->isBinaryOp() && instr->getType()->isFloatingPointTy())\n	{\n		//Create a cdag node\n		size_t nodeId = cdag ? cdag->addNode(instr->getOpcode(), \n			cast<ConstantInt>(instr->getMetadata(\"id\")->getOperand(0))->getZExtValue(),\n			0) : incNumNodesCounter();\n		for(Predecessors::iterator pred = predecessors.begin(), predEnd =	predecessors.end(); pred != predEnd;	++pred)\n		{\n			payload_type pred_data = (*pred)->get();\n			predSet.insert(pred_data.begin(), pred_data.end());\n			if(successorCountFile)\n			{\n				// we are writing successor count to file\n				std::set<size_t>::iterator setIt = pred_data.begin();\n				for(; setIt != pred_data.end(); ++setIt)\n				{\n					incSuccessorCountInFile(*setIt);\n				}\n			}\n		}\n		if(cdag) cdag->setPredecessor(nodeId, predSet);\n		node->get().clear();\n		node->get().insert(nodeId);\n	}\n	else\n	{\n		set<size_t> node_data;\n		for(Predecessors::iterator pred = predecessors.begin(), predEnd =	predecessors.end(); pred != predEnd;	++pred)\n		{\n			set<size_t> &pred_data = (*pred)->get();\n			node_data.insert(pred_data.begin(), pred_data.end());\n		}\n		node->get().clear();\n		node->get().insert(node_data.begin(), node_data.end());\n	}\n}\n#endif\n\nvoid DiskCDAGBuilder::incSuccessorCountInFile(Id nodeId)\n{\n	streampos pos(sizeof(Id)*nodeId);\n	successorCountFile.seekg(pos, ios::beg);\n	Id curVal = 0;\n	successorCountFile.read((char*)&curVal, sizeof(Id));\n\n	curVal += 1;\n\n	successorCountFile.seekp(pos, ios::beg);\n	successorCountFile.write((const char*)&curVal, sizeof(Id));\n	successorCountFile.flush();\n}\n\nsize_t DiskCDAGBuilder::incNumNodesCounter()\n{\n	if(successorCountFile)\n	{\n		Id temp = 0;\n		successorCountFile.seekp(0, fstream::end); // write to the end of the file\n		successorCountFile.write((const char*)&temp, sizeof(Id));\n		//successorCountFile.flush();\n	}\n	return numNodes++;\n}\n\nvoid DiskCDAGBuilder::printSuccessorCountFile()\n{\n	Id temp = 0, i=0;\n	cout <<\"\\n\";\n	successorCountFile.seekg(0, fstream::beg);\n	while(!successorCountFile.read((char*)&temp, sizeof(Id)).eof())\n	{\n		cout <<\"\\n\" << i++ << \" : \" << temp;\n	}\n	cout <<\"\\n\";\n}\n\n}\n\n#endif",
			"file": "include/ddg/analysis/DiskCDAG.hxx",
			"file_size": 36257,
			"file_write_time": 130717348682172418,
			"settings":
			{
				"buffer_size": 36252,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/shashank/project/test_reuse_v2/mat_mul/matmul.c",
			"settings":
			{
				"buffer_size": 647,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/shashank/project/test_reuse_v2/mat_mul/out",
			"settings":
			{
				"buffer_size": 17165227,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"Package Control: add",
				"Package Control: Add Repository"
			],
			[
				"Package Control: inst",
				"Package Control: Install Package"
			],
			[
				"Package Control: int",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/shashank/project/source_ddg",
		"/home/shashank/project/source_ddg/include",
		"/home/shashank/project/source_ddg/include/ddg",
		"/home/shashank/project/source_ddg/include/ddg/analysis",
		"/home/shashank/project/source_ddg/tools",
		"/home/shashank/project/source_ddg/tools/reuse-analysis",
		"/home/shashank/project/source_ddg/tools/reuse-analysis/include"
	],
	"file_history":
	[
		"/home/shashank/project/source_ddg/sftp-config.json",
		"/home/shashank/project/source_ddg/include/ddg/analysis/LazyGraph.hxx",
		"/home/shashank/project/source_ddg/include/ddg/analysis/Ids.hxx",
		"/home/shashank/project/source_ddg/tools/region-dynamic-graph/region-dynamic-graph.hxx",
		"/home/shashank/project/source_ddg/lib/runtime/Runtime.cxx",
		"/home/shashank/project/source_ddg/lib/instrument/InstrumentDDG.cxx",
		"/home/shashank/project/source_ddg/include/ddg/analysis/Trace.hxx",
		"/home/shashank/project/source_ddg/lib/analysis/Ids.cxx",
		"/home/shashank/project/source_ddg/tools/region-dynamic-graph/region-dynamic-graph.cxx",
		"/home/shashank/Downloads/CMakeLists(1).txt",
		"/home/shashank/project/source_ddg/.git/COMMIT_EDITMSG",
		"/home/shashank/Desktop/scratch",
		"/home/shashank/project/source_ddg/tools/dynamic-graph/dynamic-graph.cxx",
		"/home/shashank/project/source_ddg/include/ddg/analysis/DynamicGraph.hxx",
		"/home/shashank/project/source_ddg/lib/runtime/TraceCount.cxx",
		"/home/shashank/project/source_ddg/lib/analysis/Trace.cxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/LazyPartitionGraph.hxx",
		"/home/shashank/project/source_ddg/lib/analysis/DynamicGraph.cxx",
		"/home/shashank/project/source_ddg/tools/dynamic-graph/CMakeLists.txt",
		"/home/shashank/project/source_ddg/CMakeLists.txt",
		"/home/shashank/project/source_ddg/tools/region-dynamic-graph/CMakeLists.txt",
		"/home/shashank/project/source_ddg/.gitignore",
		"/home/shashank/project/source_ddg/tools/dynamic-graph/region-dynamic-graph.cxx",
		"/home/shashank/project/source_ddg/include/ddg/analysis/DynInstCounter.hxx",
		"/home/shashank/project/source_ddg/lib/analysis/DynInstCounter.cxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/TimestampVector.hxx",
		"/home/shashank/project/source_ddg/lib/instrument/Visitors.cxx",
		"/home/shashank/project/source_ddg/include/ddg/instrument/Visitors.hxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/TimestampVector.cxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/ddg-vect-rt.cxx",
		"/home/shashank/project/source_ddg/include/ddg/common/types.hxx",
		"/home/shashank/tmp/test/trace.txt",
		"/home/shashank/softwares/gcc-4.6.1/libjava/prims.cc",
		"/home/shashank/softwares/mpc-1.0.2/INSTALL",
		"/home/shashank/softwares/llvm-3.1.src/LLVMBuild.txt",
		"/home/shashank/softwares/gmp-4.3.2/INSTALL",
		"/home/shashank/softwares/mpfr-3.1.2/INSTALL",
		"/home/shashank/softwares/boost_1_49_0/bootstrap.log",
		"/home/shashank/softwares/gcc-4.6.1/INSTALL/README",
		"/home/shashank/README.txt",
		"/tmp/evince-1925/image.AUASPX.png",
		"/home/shashank/lisp_project/tests/eval/temptest",
		"/home/shashank/lisp_project/README.txt",
		"/home/shashank/lisp_project/.git/COMMIT_EDITMSG",
		"/home/shashank/lisp_project/tests/eval/classtestneg",
		"/home/shashank/lisp_project/tests/eval/postc",
		"/home/shashank/lisp_project/tests/testcase_list.txt",
		"/home/shashank/lisp_project/tests/eval/rajtest",
		"/home/shashank/lisp_project/tests/eval/classtestpos",
		"/home/shashank/lisp_project/tests/eval/sorttest",
		"/home/shashank/lisp_project/tests/parser/testcase_list-1.txt",
		"/home/shashank/lisp_project/tests/test6.expected",
		"/home/shashank/lisp_project/src/OutputHandler.java",
		"/home/shashank/lisp_project/tests/eval/negtc",
		"/home/shashank/lisp_project/src/Parser.java",
		"/home/shashank/lisp_project/src/Lex.java",
		"/home/shashank/lisp_project/tests/parser/test1",
		"/home/shashank/lisp_project/src/MyInt.java",
		"/home/shashank/lisp_project/tests/parser/listsTest",
		"/home/shashank/lisp_project/tests/parser/stagetest",
		"/home/shashank/lisp_project/src/Token.java",
		"/home/shashank/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/shashank/lisp_project/bin/.gitignore",
		"/home/shashank/lisp_project/Runfile",
		"/home/shashank/lisp_project/tests/parser/pos_tests",
		"/home/shashank/lisp_project/tests/parser/pos_tests2",
		"/home/shashank/lisp_project/tests/parser/testcase_list.txt",
		"/home/shashank/lisp_project/tests/test1.expected",
		"/home/shashank/lisp_project/out",
		"/home/shashank/lisp_project/tests/test1",
		"/home/shashank/lisp_project/tests/parser/test5",
		"/home/shashank/lisp_project/tests/invalid1",
		"/home/shashank/lisp_project/src/LispIntException.java",
		"/home/shashank/.config/sublime-text-3/Packages/navigationHistory.py",
		"/home/shashank/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/shashank/.config/sublime-text-3/Packages/User/Package Control.sublime-settings",
		"/home/shashank/lisp_project/tests/parser/test4",
		"/home/shashank/lisp_project/tests/invalid2",
		"/home/shashank/lisp_project/tests/invalid3",
		"/home/shashank/lisp_project/tests/invalid4",
		"/home/shashank/lisp_project/tests/parser/test2",
		"/home/shashank/lisp_project/tests/test8",
		"/home/shashank/lisp_project/Makefile",
		"/home/shashank/lisp_project/tests/parser/test3",
		"/home/shashank/lisp_project/tests/lex/test1.txt",
		"/home/shashank/lisp_project/tests/test7",
		"/home/shashank/lisp_project/.git/MERGE_MSG",
		"/home/shashank/lisp_project_c/tests/lex/test1.txt",
		"/home/shashank/Downloads/CMakeLists.txt",
		"/home/shashank/Desktop/singhsha.txt",
		"/home/shashank/lisp_project/.tags_sorted_by_file",
		"/home/shashank/sftp-config.json",
		"/home/shashank/lisp_project_c/Makefile",
		"/home/shashank/lisp_project/src/Debug.java",
		"/tmp/CMakeLists.txt",
		"/home/shashank/.cache/.fr-Vf8rQV/eclipse/eclipse.ini",
		"/home/shashank/.config/sublime-text-3/Packages/User/subclim_plugin.py",
		"/home/shashank/remote/jlex-1.2.6/JLex/CMakeNfa.java",
		"/home/shashank/remote/jlex-1.2.6/sootOutput/JLex.CMakeNfa.jimple",
		"/home/shashank/lisp_project/.git/info/exclude",
		"/home/shashank/remote/proj4/MyTransform.jva",
		"/home/shashank/remote/proj4/jlex-1.2.6/test.txt",
		"/home/shashank/Downloads/cg.f",
		"/home/shashank/remote/cta/MyTransform.java~",
		"/home/shashank/remote/proj3/MyTransform.java",
		"/home/shashank/lisp_project/proj_java/invalid1",
		"/home/shashank/lisp_interpreter_in_java-master/Makefile",
		"/home/shashank/lisp_interpreter_in_java-master/manifest.txt",
		"/home/shashank/lisp_project/proj_java/Makefile",
		"/home/shashank/lisp_project/proj_java/test1",
		"/home/shashank/Downloads/sha.txt",
		"/home/shashank/hpcviewer/bin/hpcviewer",
		"/home/shashank/remote/sftp-config.json",
		"/home/shashank/remote/proj3/jlex-1.2.6/test.txt",
		"/home/shashank/remote/cta/MyTransform.java",
		"/home/shashank/Desktop/sha.txt",
		"/home/shashank/remote/proj2/jlex-1.2.6/sootOutput/JLex.CLexGen.jimple",
		"/home/shashank/remote/proj2/jlex-1.2.6/test.txt",
		"/home/shashank/remote/proj2/singhsha.txt",
		"/home/shashank/remote/5239.sublime-project",
		"/home/shashank/remote/proj2/MyTransform.java",
		"/home/shashank/remote/jlex-1.2.6/test.txt",
		"/home/shashank/remote/jlex-1.2.6/sootOutput/JLex.CLexGen.jimple",
		"/home/shashank/remote/proj1/MyTransform.java",
		"/home/shashank/project/others/softwares/make-3.81/INSTALL",
		"/home/shashank/project/others/softwares/automake-1.9.6/INSTALL",
		"/home/shashank/project/others/softwares/libtool-1.5.22/INSTALL",
		"/home/shashank/project/others/softwares/autoconf-2.60/INSTALL"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			"",
			"region-dynamic-graph.cxx",
			"region-dynamic-graph.hxx",
			"*.cxx,*.hxx",
			"*.cxx;*.hxx",
			"",
			"/home/shashank/lisp_project/src/",
			"/home/shashank/lisp_project/src/Lex.java",
			"/home/shashank/lisp_project/src/Parser.java",
			"/home/shashank/lisp_project/src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"1024",
			"succsCache",
			"addUpdateNodeToBlock",
			"flushCurrentBlockToDisk",
			"updatesu",
			"addUpdateNodeToBlock",
			"blocksi",
			"2029999",
			"2029999'",
			"parallelism",
			"performBFS",
			"getid",
			"list",
			"cout",
			"generategraph",
			"generate",
			"basicblockrange",
			"builder",
			"visitnode",
			"basic",
			"withinRegion",
			"printRegionGraph",
			"traceno",
			"performBFS",
			"numEdges",
			"performBFS",
			"regionIdToNodeMap",
			"printRegionGraph",
			"regionIdToNodeMap",
			"numOfRegionNodes",
			"visitLoopIterEnd",
			"RegionDynamicGraphBuilder",
			"loopIndVar",
			"LoopIndVar",
			"loopIndVar",
			"class TraceVisitor",
			"handleRegionBegin",
			"loopIndVar",
			"LoopIndVar",
			"loopIndVar",
			"LoopIndVar",
			"loopIndVar",
			"LoopIndVar",
			"loopIndVar",
			"LoopIndVar",
			"loopIndVar",
			"regionBegin",
			"LazyGraphBuilder",
			"DynamicGraph",
			"generateGraph",
			"visitNode",
			"visit(",
			"visit",
			"addSuccessor",
			"addNode",
			"LazyGraphBuilder",
			"LazyNode",
			"LastAddrWriterMap",
			"lastAddrWriters",
			"lastInstrWriters",
			"basicBlocks",
			"ids",
			"Ids",
			"TraceEventsHandler",
			"ids",
			"Ids",
			"ids",
			"TraceVisitor",
			"ParseIRFile",
			"SUBCLASS",
			"handleLd",
			"handleBB",
			"handleRegionBegin",
			"IdsVisitor",
			"bbId",
			"ddg_basic_block_enter",
			"ddg_load",
			"LoopBegin",
			"FnCallType",
			"RegionBegin",
			"ddg_load",
			"LoopEndType",
			"LoopBeginType",
			"RegionEndType",
			"RegionBeginType",
			"RegionEnd",
			"RegionBegin",
			"LoopBegin",
			"TraceEnd",
			"LoopBegin",
			"handleRegionEnd",
			"region",
			"ddg_end_region",
			"ddg_begin_region",
			"endRegionFn",
			"beginRegionFn",
			"region",
			"start",
			"ddg_stop_region",
			"stopRegionFn",
			"startRegionFn",
			"region",
			"LoopEnter",
			"Load",
			"LoopExitType",
			"handleEndTrace",
			"handleRegionStart",
			"handleEndTrace",
			"loopId",
			"LoopId",
			"loopId",
			"LoopId",
			"loopId",
			"LoopId",
			"loopId",
			"LoopId",
			"loopId",
			"LoopEnterType",
			"ddg_start_trace",
			"NumberingVisitor",
			"ddg_start_trace",
			"CHECK_TRACING",
			"ddg_load",
			"isspace ",
			"zlib",
			"getVal",
			"out.dump",
			"addPairs"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"RegionDynamicGraph",
			"ddg_region_end",
			"ddg_region_begin",
			"regionEndFn",
			"regionBeginFn",
			"endRegionFn",
			"beginRegionFn",
			"c_isspace",
			"out.dump",
			""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "include/ddg/analysis/DiskCache.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16760,
						"regions":
						{
						},
						"selection":
						[
							[
								1829,
								1829
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1188.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "tools/reuse-analysis/include/ReadCDAG.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2422,
						"regions":
						{
						},
						"selection":
						[
							[
								1816,
								1816
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 702.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 2,
					"file": "include/ddg/analysis/DiskCDAG.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 36252,
						"regions":
						{
						},
						"selection":
						[
							[
								13678,
								13678
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 9158.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/home/shashank/project/test_reuse_v2/mat_mul/matmul.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 647,
						"regions":
						{
						},
						"selection":
						[
							[
								156,
								156
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/home/shashank/project/test_reuse_v2/mat_mul/out",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17165227,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.488950276243,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 118.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.sftp":
	{
		"height": 112.0
	},
	"pinned_build_system": "",
	"project": "source_ddg.sublime-project",
	"replace":
	{
		"height": 48.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"traceno",
				"lib/runtime/TraceCount.cxx"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 226.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
