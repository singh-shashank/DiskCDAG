{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"avai",
				"availableDataNodesQ"
			],
			[
				"Pool",
				"PoolHandlerCircularQ"
			],
			[
				"print",
				"printPoolHandlerQ"
			],
			[
				"getI",
				"getItemFromPool"
			],
			[
				"push",
				"push_back"
			],
			[
				"pool",
				"poolVec"
			],
			[
				"add",
				"addItemToPool"
			],
			[
				"cur",
				"curSize"
			],
			[
				"start",
				"startV"
			],
			[
				"bitSet",
				"bitSetIndex"
			],
			[
				"size",
				"sizeof"
			],
			[
				"ava",
				"availableSlotIdIndexObjsQ"
			],
			[
				"Ava",
				"availableDataNodesQ"
			],
			[
				"data",
				"dataIdToSlotMap"
			],
			[
				"avaial",
				"availableSlotIdIndexObjsQ"
			],
			[
				"getA",
				"getAvailableSlotIdSlotIndexObj"
			],
			[
				"dataFil",
				"dataFileName"
			],
			[
				"Slot",
				"SlotIdSlotIndex"
			],
			[
				"MAX",
				"MAX_ITEMS_IN_CACHE"
			],
			[
				"el",
				"elapsed_time"
			],
			[
				"clo",
				"clock_t"
			],
			[
				"bit",
				"bitset"
			],
			[
				"unmar",
				"unmarkNode"
			],
			[
				"q",
				"qBitSetForNodes"
			],
			[
				"numof",
				"numOfBytesFornodeMarkerBitSet"
			],
			[
				"star",
				"startV"
			],
			[
				"bfs",
				"bfsOutFile"
			],
			[
				"graph",
				"graphDumpFile"
			],
			[
				"writeto",
				"writeToStreamInBinary"
			],
			[
				"stat",
				"staticId"
			],
			[
				"marked",
				"markedNodeCount"
			],
			[
				"diskGraphF",
				"diskGraphFileName"
			],
			[
				"dataId",
				"dataIdBlockRangeList"
			],
			[
				"disk",
				"diskGraphFileName"
			],
			[
				"bc",
				"bcFileName"
			],
			[
				"dis",
				"diskGraphIndexFileName"
			],
			[
				"gra",
				"graphCreatedFlag"
			],
			[
				"diskGraphIndexF",
				"diskGraphIndexFileName"
			],
			[
				"diskGra",
				"diskGraphIndex"
			],
			[
				"file",
				"fileWriteBS"
			],
			[
				"clean",
				"cleanUpTemporaries"
			],
			[
				"alloc",
				"allocId"
			],
			[
				"CD",
				"CDAGNode"
			],
			[
				"CDAG",
				"CDAGNode"
			],
			[
				"reset",
				"resetGraphState"
			],
			[
				"gram",
				"graphDumpFile"
			],
			[
				"Region",
				"RegionNode"
			],
			[
				"visit",
				"visited"
			],
			[
				"us",
				"unsigned"
			],
			[
				"all",
				"allPredsForRegion"
			],
			[
				"succs",
				"succsList"
			],
			[
				"succ",
				"succsList"
			],
			[
				"RegioN",
				"RegionNode"
			],
			[
				"with",
				"withinRegion"
			],
			[
				"visitReg",
				"visitRegionEnd"
			],
			[
				"node",
				"nodeCnt"
			],
			[
				"regio",
				"regionIdToNodeMap"
			],
			[
				"region",
				"regionId"
			],
			[
				"handleReg",
				"handleRegionBegin"
			],
			[
				"Regio",
				"RegionStart"
			],
			[
				"handleRe",
				"handleRegionStart"
			],
			[
				"ddg_s",
				"ddg_start_region"
			],
			[
				"dum",
				"dump"
			],
			[
				"bod",
				"bodyList"
			],
			[
				"formal",
				"formalList"
			],
			[
				"tok",
				"TokenType"
			],
			[
				"cre",
				"createTrueAtom"
			],
			[
				"eval",
				"evalRelFns"
			],
			[
				"evala",
				"evalArithmeticFns"
			],
			[
				"create",
				"createTrueAtom"
			],
			[
				"crea",
				"createNilAtom"
			],
			[
				"evalC",
				"evalCar"
			],
			[
				"is",
				"isBound"
			],
			[
				"ret",
				"retVal"
			],
			[
				"eva",
				"evalNULL"
			],
			[
				"set",
				"setTerminalChar2"
			],
			[
				"right",
				"rightStr"
			],
			[
				"setTermi",
				"setTerminalChars"
			],
			[
				"Li",
				"LiteralAtom"
			],
			[
				"left",
				"leftStr"
			],
			[
				"termi",
				"terminalChar1"
			],
			[
				"getTok",
				"getTokenType"
			],
			[
				"dump",
				"dumpSExpStack"
			],
			[
				"getToke",
				"getTokenType"
			],
			[
				"getT",
				"getTokenStringValue"
			],
			[
				"Se",
				"SExp"
			],
			[
				"SEx",
				"SExp"
			],
			[
				"parseT",
				"parseTerminalSExp"
			],
			[
				"SE",
				"SExp"
			],
			[
				"get",
				"getTokenType"
			],
			[
				"pee",
				"peekNextToken"
			],
			[
				"getotk",
				"getTokenStringValue"
			],
			[
				"Toke",
				"TokenType"
			],
			[
				"token",
				"tokensQ"
			],
			[
				"getTer",
				"getTerminalChar2"
			],
			[
				"com",
				"compoundExp"
			],
			[
				"teri",
				"terminalChar1"
			],
			[
				"Sys",
				"System"
			],
			[
				"Output",
				"OutputStreamWriter"
			],
			[
				"toke",
				"tokensQ"
			],
			[
				"sys",
				"symStack"
			],
			[
				"sym",
				"symStack"
			],
			[
				"non",
				"nonTerminalOnTop"
			],
			[
				"symb",
				"symbList"
			],
			[
				"prod",
				"prodNumber"
			],
			[
				"Ex",
				"Exception"
			],
			[
				"T_",
				"T_OPEN_PARAN"
			],
			[
				"Tok",
				"TokenType"
			],
			[
				"S",
				"Symbol"
			],
			[
				"pu",
				"push"
			],
			[
				"T_E",
				"T_EOF"
			],
			[
				"sy",
				"symStack"
			],
			[
				"parse",
				"parseTable"
			],
			[
				"termina",
				"terminalChar"
			],
			[
				"pars",
				"parseCompoundSExp"
			],
			[
				"getTo",
				"getTokenType"
			],
			[
				"getTOke",
				"getTokenType"
			],
			[
				"le",
				"left"
			],
			[
				"term",
				"terminalChar"
			],
			[
				"Toe",
				"TokenType"
			],
			[
				"par",
				"parseTerminalSExp"
			],
			[
				"Token",
				"Token"
			],
			[
				"E",
				"Exception"
			],
			[
				"cahr",
				"charAt"
			],
			[
				"nex",
				"nextToken"
			],
			[
				"Erro",
				"ErrorString1"
			],
			[
				"char",
				"charAt"
			],
			[
				"t",
				"t	test"
			]
		]
	},
	"buffers":
	[
		{
			"file": "include/ddg/analysis/DiskCache.hxx",
			"settings":
			{
				"buffer_size": 25621,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/ddg/analysis/DiskCDAG.hxx",
			"settings":
			{
				"buffer_size": 46900,
				"line_ending": "Unix"
			}
		},
		{
			"file": "tools/reuse-analysis/include/ReadCDAG.hxx",
			"settings":
			{
				"buffer_size": 2960,
				"line_ending": "Unix"
			}
		},
		{
			"file": "tools/reuse-analysis/src/Main.cxx",
			"settings":
			{
				"buffer_size": 4932,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include <fstream>\n#include <iostream>\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <deque>\n\n#define DEBUG(msg) do { if (!DEBUG_ENABLED) {} \\\n                   else std::cout << __FILE__ << \":\" << __LINE__ << \" \" << msg; \\\n               		} while(0)\n#ifdef DEBUG_FLAG\n#define DEBUG_ENABLED 1\n#else\n#define DEBUG_ENABLED 0\n#endif\n\n//#define DEBUG_ENABLED 1\n\nnamespace ddg{\n\n	using namespace std;\n	using namespace llvm;\n\n	template <typename Data, typename DataId>\n	class DiskCache\n	{\n	public:\n		DiskCache(int bs, int numSlots, bool flag = false): BLOCK_SIZE(bs),\n									  NUM_SLOTS(numSlots),\n									  writeBackFlag(flag),\n									  initFlag(false),\n									  dataCount(),\n									  MAX_ITEMS_PER_SLOT(BLOCK_SIZE/sizeof(Data)),\n									  MAX_ITEMS_IN_CACHE(MAX_ITEMS_PER_SLOT*NUM_SLOTS)\n		{}\n\n		~DiskCache()\n		{\n			// Invalidate all the slots\n			for(int i=0; i<NUM_SLOTS; ++i)\n			{\n				invalidateSlot(i);\n			}\n\n			// clear up all the pre-allocated objects\n			// while(!availableDataNodesQ.empty())\n			// {\n			// 	delete availableDataNodesQ.front();\n			// 	availableDataNodesQ.pop_front();\n			// }\n			// while(!availableSlotIdIndexObjsQ.empty())\n			// {\n			// 	delete availableSlotIdIndexObjsQ.front();\n			// 	availableSlotIdIndexObjsQ.pop_front();\n			// }\n\n			while(!availableDataNodesQ->empty())\n			{\n				delete availableDataNodesQ->getItemFromPool();\n			}\n			while(!availableSlotIdIndexObjsQ->empty())\n			{\n				delete availableSlotIdIndexObjsQ->getItemFromPool();\n			}\n			delete availableDataNodesQ;\n			delete availableSlotIdIndexObjsQ;\n\n			// Delete slots\n			delete []slots;\n\n			// Delete use list\n			ListNode *curNode = useListHead;\n			while(curNode)\n			{\n				ListNode *temp = curNode;\n				curNode = curNode->next;\n				delete temp;\n			}\n		}\n\n		bool init(const string &file,					\n					const string &indexFile =\"\",\n					const unsigned int p=0)\n		{\n			initFlag = true;\n\n			if(BLOCK_SIZE == 0 || BLOCK_SIZE < sizeof(Data) || NUM_SLOTS == 0)\n			{\n				initFlag = false;\n				return initFlag;\n			}\n\n			policy = p;\n			dataFileName = file;\n			slots = new SLOT[NUM_SLOTS];\n\n			// Initialize use list\n			useListHead = new ListNode(0);\n			ListNode *curNode = useListHead;\n			slotIdToListNodeMap[0] = useListHead;\n			for(int i=1; i<NUM_SLOTS; ++i)\n			{\n				ListNode *temp = new ListNode(i);\n				temp->prev = curNode;\n				curNode->next = temp;\n				curNode = temp;\n				slotIdToListNodeMap[i] = temp;\n			}\n			useListTail = curNode;\n\n			// open handles to required files\n			if(!initFileHandle(dataFileName, dataFileHandle, writeBackFlag)){\n				cout << \"\\n Error in opening data file\";\n				initFlag = false;\n			}\n			if(!indexFile.empty() && !initFileHandle(indexFile, dataIndexFileHandle)){\n				cout << \"\\n Error in opening index file\";\n				initFlag = false;\n			}\n\n			// If all is well till now, read in the index file\n			if(initFlag){\n				cout << \"\\n Indexing the data file...\" << flush;\n				if(!indexFile.empty())\n				{\n					readDataIndexFile();\n				}\n				else\n				{\n					// no data index file specified\n					bool temp = writeBackFlag;\n					writeBackFlag = false;\n					createDataIndex(false);\n					writeBackFlag = temp;\n				}\n				dataCount = dataIdBlockRangeList.size() > 0 ? dataIdBlockRangeList[dataIdBlockRangeList.size()-1].end : 0;\n				cout << \"done!\";\n			}\n\n			// We have a valid data count now\n			DEBUG(\"\\nData count for \" << dataFileName << \": \" << dataCount);\n			unsigned int maxDataObjectsRequired = MAX_ITEMS_IN_CACHE+1;\n			if(dataCount > MAX_ITEMS_IN_CACHE)\n			{\n				// Reserve memory for slots\n				for(int i=0; i<NUM_SLOTS; ++i)\n				{\n					slots[i].reserve(MAX_ITEMS_PER_SLOT+1);\n				}\n			}\n			else\n			{\n				// We have enough space in cache to avoid data eviction.\n				// Just pre-allocate Data and SlotIdSlotIndex objects\n				maxDataObjectsRequired = dataCount + 10;\n\n			}\n			// Pre-allocate Data and SlotIdSlotIndex objects\n			// for(int i=0; i<maxDataObjectsRequired; ++i)\n			// {\n			// 	Data *node = new Data();\n			// 	availableDataNodesQ.push_back(node);\n\n			// 	SlotIdSlotIndex *obj = new SlotIdSlotIndex();\n			// 	availableSlotIdIndexObjsQ.push_back(obj);\n			// }\n			// DEBUG(\"\\n availableDataNodes : \" << availableDataNodesQ.size());\n			// DEBUG(\"\\n availableSlotIdIndexObjs : \" << availableSlotIdIndexObjsQ.size());\n\n			availableDataNodesQ = new CircularQ<Data*>(maxDataObjectsRequired);\n			availableSlotIdIndexObjsQ = new CircularQ<SlotIdSlotIndex*>(maxDataObjectsRequired);\n			for(int i=0; i<maxDataObjectsRequired; ++i)\n			{\n				Data *node = new Data();\n				availableDataNodesQ->addItemToPool(node);\n\n				SlotIdSlotIndex *obj = new SlotIdSlotIndex();\n				availableSlotIdIndexObjsQ->addItemToPool(obj);\n			}\n\n			return initFlag;\n		}\n\n		DataId getDataCount()\n		{\n			return dataCount;\n		}\n\n		virtual void createDataIndex(bool dumpToFile)\n		{\n			DEBUG(\"\\n Create index for the data file in cache.\\n\");\n			// clear any flags set and reset the file pointer to beginning\n			dataFileHandle.clear();\n			dataFileHandle.seekg(0, ios::beg);\n\n			// start creating the index\n			streampos startPos = 0;\n			DataId begin = 0, end = 0;\n			while(dataFileHandle.peek() != EOF)\n			{\n				startPos = dataFileHandle.tellg();\n				// int slotId = getAvailableSlot();\n				// // Invalidate the current slot before reading\n				// invalidateSlot(slotId);\n				// readBlockInSlot(slotId, 0); // we don't care about the DataId being passed in\n				// int count = slots[slotId].size();\n				// if(count > 0)\n				// {\n				// 	DataIdRange range;\n				// 	range.setRange(slots[slotId][0]->getId(),\n				// 					slots[slotId][count-1]->getId(),\n				// 					startPos);\n				// 	dataIdBlockRangeList.push_back(range);\n				// }\n				begin = 0, end =0;\n				readBlockForDataIndexing(begin, end);\n				DataIdRange range;\n				range.setRange(begin,\n								end,\n								startPos);\n				dataIdBlockRangeList.push_back(range);\n			}\n\n			sort(dataIdBlockRangeList.begin(), dataIdBlockRangeList.end());\n\n			// Test code: Iterate over set to print block range\n			if(DEBUG_ENABLED)\n			{\n				DEBUG(\"\\n Printing block offset range\");\n				typename vector<DataIdRange>::iterator it = dataIdBlockRangeList.begin();\n				for(; it != dataIdBlockRangeList.end(); ++it)\n				{\n					(*it).printRange();\n				}\n				DEBUG(\"\\n Index created for thed data file\\n\");\n			}\n		}\n\n		// Gets a read-only pointer to the data\n		virtual Data* getData(const DataId id)\n		{\n			Data *retVal = 0;\n			SlotIdSlotIndex* dataInfo = isInCache(id);\n			int slotId = dataInfo ? dataInfo->slotId : -1;\n			int slotIndex = dataInfo ? dataInfo->slotIndex : -1;\n			dataInfo = 0;\n			if(slotId < 0)\n			{\n				DEBUG(\"\\n\" << id <<\" is not in cache\");\n				// Get a slot id to read a block into.\n				slotId = getAvailableSlot();\n				// Invalidate the current slot before reading\n				invalidateSlot(slotId);\n\n				// Find the block having the data and its \n				// seek position in the file.\n				// Seek to the required block in the file.\n				streampos off = getStreamOffsetForDataId(id);\n				DEBUG(\"\\n getData : \" << id << \", seeking to \" << off);\n				seekForRead(dataFileHandle, off);\n				DEBUG(\"\\n and seeked to \" << dataFileHandle.tellg());\n				\n\n				// Read the block in slot.\n				slotIndex = readBlockInSlot(slotId, id);\n\n			}\n			else\n			{\n				DEBUG(\"\\n\" << id <<\" is in cache at slot : \" << slotId);\n			}\n\n			// The requested data should exists in cache.\n			if(slotIndex == -1)\n			{\n				cout <<\"\\n FATAL CACHE ERROR : Sync error between cache data structures!\";\n				cout <<\"\\n Was trying to fetch data with id :\" << id;\n				cout <<flush;\n				retVal = 0;\n			}\n			else\n			{\n				retVal = slots[slotId][slotIndex];\n			}\n			\n			// Update the use list to mark this slot\n			markSlotAsMRU(slotId);\n			return retVal;\n		}\n\n\n		virtual int getAvailableSlot()\n		{\n			int retVal = -1;\n			switch (policy)\n			{\n				case 0:\n				default:\n					retVal = applyLRUPolicy();\n					break;\n			}\n\n			return retVal; // the default policy \n		}\n\n	private:\n\n		struct SlotIdSlotIndex\n		{\n			int slotId;\n			int slotIndex;\n			SlotIdSlotIndex(int s, int ind):slotId(s), slotIndex(ind)\n			{}\n\n			SlotIdSlotIndex():slotId(-1), slotIndex(-1)\n			{}\n\n			SlotIdSlotIndex& operator = (const SlotIdSlotIndex& rhs)\n			{\n				slotId = rhs.slotId;\n				slotIndex = rhs.slotIndex;\n				return *this;\n			}\n			void reset()\n			{\n				slotId = -1, slotIndex = -1;\n			}	\n\n			void setValues(unsigned int &s, unsigned int &ind)\n			{\n				slotId = s;\n				slotIndex = ind;\n			}\n		};\n\n		// This method assumes that dataFileHandle is pointing to \n		// appropriate block in the file. Will read from the current\n		// seek position. Caller should seek into the appropriate location\n		// in the file\n		int readBlockInSlot(const unsigned int slotId, DataId id)\n		{\n			assert(slotId < NUM_SLOTS);\n			DEBUG(\"\\n readBlockInSlot \"<<slotId);\n\n			// Start reading from the file\n			// Implementation Note :-\n			// From the API perspective its good idea to stop reading \n			// when you reach the Block size and not when you reached \n			// the next block offset as specified by the data index \n			// data structure\n			size_t curSize = 0;\n			DataId begin = INT_MAX, end = 0;\n			int slotIndex = -1;\n			while(true)\n			{\n				Data* node = getAvailableDataNode();\n				streampos beforeReadOff = dataFileHandle.tellg();\n				//node->readNodeFromASCIIFile(dataFileHandle);\n				node->readNodeFromBinaryFile(dataFileHandle);\n				// TODO : a check to see if the read node is valid\n				curSize += sizeof(*node);\n				if(curSize < BLOCK_SIZE && dataFileHandle.tellg() != -1)\n				{\n					slots[slotId].push_back(node);\n					//SlotIdSlotIndex dataInfo(slotId, slots[slotId].size()-1);\n					SlotIdSlotIndex *dataInfo = getAvailableSlotIdSlotIndexObj();\n					unsigned int ind = (slots[slotId].size()-1);\n					dataInfo->setValues(slotId, ind);\n					dataIdToSlotMap[node->getId()] = dataInfo;\n					if(id == node->getId())\n						slotIndex = slots[slotId].size()-1;\n				}\n				else\n				{\n					//availableDataNodesQ.push_back(node);\n					availableDataNodesQ->addItemToPool(node);\n					// we have read an extra data node.\n					// Seek back by the size of the node read\n					//dataFileHandle.seekg(beforeReadOff, ios::beg);\n					if(dataFileHandle.eof())\n					{\n						// If we reached the eof then beforeReadOff is\n						// set to -1 and the subsequent read would set\n						// the fail bit. (TODO fix the subsquent read)\n						// Go to the beginning of the file.\n						//seekForRead(dataFileHandle, 0);\n\n						// THERE IS SOMETHING FISHY HERE. COMMENTING IT FOR\n						// NOW. \n					}\n					else\n					{\n						seekForRead(dataFileHandle, beforeReadOff);\n					}\n					break;\n				}\n			}\n\n			if(DEBUG_ENABLED)\n			{\n				DEBUG(\"\\nreadBlockInSlot : done reading the slot. Dumping slot\\n\");\n				dumpSlot(slotId);\n			}\n			return slotIndex;\n		}\n\n		void readBlockForDataIndexing(DataId &begin, DataId &end)\n		{\n			DEBUG(\"\\n readBlockForDataIndexing \");\n\n			// Start reading from the file\n			// Implementation Note :-\n			// From the API perspective its good idea to stop reading \n			// when you reach the Block size and not when you reached \n			// the next block offset as specified by the data index \n			// data structure\n			size_t curSize = 0;\n			bool firstNode = true;\n			Data* node = new Data();\n			while(true)\n			{\n				node->reset();\n				streampos beforeReadOff = dataFileHandle.tellg();\n				//node->readNodeFromASCIIFile(dataFileHandle);\n				node->readNodeFromBinaryFile(dataFileHandle);\n				// TODO : a check to see if the read node is valid\n				curSize += sizeof(*node);\n				if(curSize < BLOCK_SIZE && dataFileHandle.tellg() != -1)\n				{\n					if(firstNode)\n					{\n						firstNode = false;\n						begin = node->getId();\n					}\n					end = node->getId();\n				}\n				else\n				{\n					// we have read an extra data node.\n					// Seek back by the size of the node read\n					//dataFileHandle.seekg(beforeReadOff, ios::beg);\n					if(dataFileHandle.eof())\n					{\n						// If we reached the eof then beforeReadOff is\n						// set to -1 and the subsequent read would set\n						// the fail bit. (TODO fix the subsquent read)\n						// Go to the beginning of the file.\n						//seekForRead(dataFileHandle, 0);\n\n						// THERE IS SOMETHING FISHY HERE. COMMENTING IT FOR\n						// NOW. \n					}\n					else\n					{\n						seekForRead(dataFileHandle, beforeReadOff);\n					}\n					break;\n				}\n			}\n			delete node;\n		}\n\n		void dumpSlot(int slotId)\n		{\n			if(slots[slotId].size() < 1)\n			{\n				cout << \"Empty Slot\";\n				return;\n			}\n			SLOT_ITERATOR it = slots[slotId].begin();\n			for(; it != slots[slotId].end(); ++it)\n			{\n				cout << (*it)->getId() <<\" \";\n			}\n		}\n\n		void invalidateSlot(const unsigned int slotId)\n		{\n			assert(slotId < NUM_SLOTS);\n\n			if(writeBackFlag && slots[slotId].size() > 0)\n			{\n				DEBUG(\"\\n Doing a write back for slot : \"<<slotId);\n				SLOT_ITERATOR it = slots[slotId].begin();\n				Id firstEleId = (*it)->getId();\n				seekForWrite(dataFileHandle, getStreamOffsetForDataId(firstEleId));\n				DEBUG(\" with tellp() value at : \" << dataFileHandle.tellp());\n				for(; it != slots[slotId].end(); ++it)\n				{\n					(*it)->writeToStream(dataFileHandle);\n					//(*it)->print(cout);\n				}\n				dataFileHandle.flush();\n			}\n\n			// move all the used data nodes to available queue\n			// and then empty the dictionary container\n			SLOT_ITERATOR it = slots[slotId].begin();\n			for(; it != slots[slotId].end(); ++it)\n			{\n				// availableSlotIdIndexObjsQ.push_back(dataIdToSlotMap[(*it)->getId()]);\n				availableSlotIdIndexObjsQ->addItemToPool(dataIdToSlotMap[(*it)->getId()]);\n				dataIdToSlotMap.erase((*it)->getId());\n				//availableDataNodesQ.push_back(*it);\n				availableDataNodesQ->addItemToPool(*it);\n			}\n\n			slots[slotId].clear();\n		}\n\n		Data* getAvailableDataNode()\n		{\n			Data *retVal = 0;\n			if(!availableDataNodesQ->empty())\n			{\n				retVal = availableDataNodesQ->getItemFromPool();\n				//availableDataNodesQ.pop_front();\n				retVal->reset();\n			}\n			else\n			{\n				cout << \"\\n Warning : Allocating a new Data node!\";\n				cout << \" Shouldn't happen if the nodes were pre-allocated\";\n				retVal = new Data();\n			}\n			return retVal;\n		}\n		SlotIdSlotIndex* getAvailableSlotIdSlotIndexObj()\n		{\n			SlotIdSlotIndex *retVal = 0;\n			if(!availableSlotIdIndexObjsQ->empty())\n			{\n				retVal = availableSlotIdIndexObjsQ->getItemFromPool();\n				// availableSlotIdIndexObjsQ.pop_front();\n				retVal->reset();\n			}\n			else\n			{\n				cout << \"\\n Warning : Allocating a new SlotIdSlotIndex object!\";\n				cout << \" Shouldn't happen if the nodes were pre-allocated\";\n				retVal = new SlotIdSlotIndex();\n			}\n			return retVal;\n		}\n\n		SlotIdSlotIndex* isInCache(const DataId id)\n		{\n			SlotIdSlotIndex *dataInfo = 0;\n			DATA_TO_SLOT_MAP_ITERATOR it = dataIdToSlotMap.find(id);\n			if(it != dataIdToSlotMap.end())\n			{\n				dataInfo = (it->second);\n			}\n			return dataInfo;\n		}\n\n		int applyLRUPolicy()\n		{\n			// the head of the use list marks the least recently used\n			// slot. Return the id and subsequent call to markSlotAsMRU\n			// will move this list node to the tail.\n			return useListHead->slotId;\n		}\n\n		void markSlotAsMRU(const int slotId)\n		{\n			ListNode *curNode = slotIdToListNodeMap[slotId];\n			\n			// If its already at the tail then we can simply return\n			if(curNode == useListTail)\n				return;\n\n			// Else move this list node to the tail\n			if(curNode == useListHead)\n			{\n				curNode->next->prev = 0;\n				useListHead = curNode->next;\n			}\n			else\n			{\n				// its a middle node\n				curNode->prev->next = curNode->next;\n				curNode->next->prev = curNode->prev;\n			}\n			curNode->prev = useListTail;\n			useListTail->next = curNode;\n			curNode->next = 0;\n\n			useListTail = curNode;\n		}\n\n		bool initFileHandle(const string &name, fstream &handle, bool rwMode=false)\n		{\n			bool retVal = true;\n			if(name.empty())\n			{\n				retVal = false;\n			}\n			if(rwMode)\n			{\n				handle.open(name.c_str(), fstream::in|fstream::out);\n			}\n			else\n			{\n				handle.open(name.c_str(), fstream::in);\n			}\n\n			if(!handle)\n				retVal = false;\n			return retVal;\n		}\n\n		void readDataIndexFile()\n		{\n			//cout << \"\\n In disk cache readDataIndexFile \\n\";\n			int i=0;\n			streampos pos(0);\n			streampos prev(0);\n			DataId begin = i;\n			while(dataIndexFileHandle.read((char*)&pos, sizeof(streampos)).good())\n			{				\n				//cout << (long)pos <<\" \";\n				if(pos != prev)\n				{\n					DataIdRange range;\n					range.setRange(begin, i-1, prev);\n					dataIdBlockRangeList.push_back(range);\n					begin = i;\n					prev = pos;\n				}\n				pos = 0;\n				++i;\n			}\n\n			DataIdRange range;\n			range.setRange(begin, i-1, prev);\n			dataIdBlockRangeList.push_back(range);\n			sort(dataIdBlockRangeList.begin(), dataIdBlockRangeList.end());\n\n			// Test code: Iterate over set to print block range\n			if(DEBUG_ENABLED)\n			{\n				DEBUG(\"\\n Priting block offset range\");\n				typename vector<DataIdRange>::iterator it = dataIdBlockRangeList.begin();\n				for(; it != dataIdBlockRangeList.end(); ++it)\n				{\n					(*it).printRange();\n				}\n			}\n		}\n\n		streampos getStreamOffsetForDataId(DataId &id)\n		{\n			int start = 0, end = dataIdBlockRangeList.size()-1, mid;\n			streampos retVal = -1;\n			while(start <= end)\n			{\n				mid  = (start + end) >> 1;\n				if(dataIdBlockRangeList[mid].isInRange(id))\n				{\n					retVal = dataIdBlockRangeList[mid].pos;\n					break;\n				}\n				else if(id < dataIdBlockRangeList[mid].begin)\n				{\n					end = mid-1;\n				}\n				else\n				{\n					start = mid+1;\n				}\n			}\n			return retVal;\n		}\n\n		void seekForRead(fstream &handle, streampos offset)\n		{\n			// if(handle.is_open())\n			// {\n			// 	cout <<\"\\n In seekForRead - Handle is open.\"	;\n			// }\n			// if(handle.fail())\n			// {\n			// 	cout <<\"\\n In seekForRead - Fail bit set\";\n			// }\n			// if(handle.bad())\n			// {\n			// 	cout <<\"\\n In seekForRead - bad bit set\";\n			// }\n			// if(handle.good())\n			// {\n			// 	cout <<\"\\n In seekForRead - Good bit set\";\n			// }\n			// if(handle.eof())\n			// {\n			// 	cout << \"\\n In seekForRead - Eof bit set\";\n			// }\n			handle.seekg(offset, ios::beg);\n			if(handle.tellg() == -1)\n			{\n				if(handle.eof() || handle.fail())\n				{\n					handle.clear();\n					handle.seekg(offset, ios::beg); //reset to beginning\n					DEBUG(\"\\nReached end of file - reset to beginning\");\n				}\n				else\n				{\n					// handle.seekg(0, ios::beg); //reset to beginning\n					cout << \"\\n Cache error in stream associated with file :\" << dataFileName;\n				}\n			}\n		}\n\n		void seekForWrite(fstream &handle, streampos offset)\n		{\n			// if(handle.is_open())\n			// {\n			// 	cout <<\"\\n In seekForWrite - Handle is open.\"	;\n			// }\n			// if(handle.fail())\n			// {\n			// 	cout <<\"\\n In seekForWrite - Fail bit set\";\n			// }\n			// if(handle.bad())\n			// {\n			// 	cout <<\"\\n In seekForWrite - bad bit set\";\n			// }\n			// if(handle.good())\n			// {\n			// 	cout <<\"\\n In seekForWrite - Good bit set\";\n			// }\n			// if(handle.eof())\n			// {\n			// 	cout << \"\\n In seekForWrite - Eof bit set\";\n			// }\n			handle.seekp(offset, ios::beg);\n			if(handle.tellp() == -1)\n			{\n				if(handle.eof() || handle.fail())\n				{\n					handle.clear();\n					handle.seekp(offset, ios::beg); //reset to beginning\n					DEBUG(\"\\n Reached end of file - reset to beginning\");\n				}\n				else\n				{\n					// handle.seekg(0, ios::beg); //reset to beginning\n					cout << \"\\n Cache error in stream associated with file :\" << dataFileName;\n				}\n			}\n		}\n\n		// Member variables and data structures\n		struct ListNode\n		{\n			ListNode *prev;\n			ListNode *next;\n			int slotId;\n			ListNode(int id):slotId(id),\n							 prev(0),\n							 next(0)\n			{}\n		};\n\n		struct DataIdRange{\n		 	DataId begin;\n		 	DataId end;\n		 	int slotId;\n		 	streampos pos;\n\n		 	DataIdRange():begin(-1), end(-1), pos(-1), slotId(-1){}\n\n		 	bool operator< (const DataIdRange& other) const\n		 	{\n		 		return this->end < other.end;\n		 	}\n\n		 	bool isInRange(DataId id)\n		 	{\n		 		return (begin <= id && id <= end);\n		 	}\n\n		 	void setRange(DataId b, DataId e, int slot)\n		 	{\n		 		begin = b; end = e; slotId = slot;\n		 	}\n\n		 	void setRange(DataId b, DataId e, streampos p)\n		 	{\n		 		begin = b; end = e; pos = p;\n		 	}\n\n		 	void printRange() const\n		 	{\n		 		cout << \"\\n\" << begin << \" - \" <<end << \" : \" <<pos;\n		 	}\n		};\n\n		// Use Vectors for slots because we want to exploit spatial \n		// locality and its optimized because indexing a file tells\n		// us the number of items we are expecting in cache.\n		typedef typename std::vector<Data*> SLOT;\n		typedef typename std::vector<Data*>::iterator SLOT_ITERATOR;\n		typedef typename std::map<DataId, SlotIdSlotIndex*> DATA_TO_SLOT_MAP;\n		typedef typename std::map<DataId, SlotIdSlotIndex*>::iterator DATA_TO_SLOT_MAP_ITERATOR;\n\n		const size_t BLOCK_SIZE;\n		const int NUM_SLOTS;\n		string dataFileName;\n		bool initFlag;\n		unsigned int policy;\n		bool writeBackFlag;\n		const unsigned int MAX_ITEMS_PER_SLOT;\n		const unsigned int MAX_ITEMS_IN_CACHE;\n		DataId dataCount;\n\n		SLOT *slots;\n		DATA_TO_SLOT_MAP dataIdToSlotMap;	\n\n		ListNode *useListHead; // represents the LRU slot\n		ListNode *useListTail; // represents the MRU slot\n		map<int, ListNode*>  slotIdToListNodeMap; // map for a quick markSlotAsMRU() implementation\n\n		fstream dataFileHandle;\n		fstream dataIndexFileHandle;\n\n		vector<DataIdRange> dataIdBlockRangeList;\n\n		// Object pool for BIG performance improvements\n		// especially when we are dealing with millions of\n		// data items.\n		// deque<Data*> availableDataNodesQ;\n		// deque<SlotIdSlotIndex*> availableSlotIdIndexObjsQ;\n		// Using circular queue to check performance improvement\n\n\n	public:\n		// Implementing a fixed sized queue for pool handler\n		// to verify if it gives some performance improvements\n		template <typename T>\n		class CircularQ\n		{\n		public:\n			CircularQ(unsigned int capacity):popPos(-1), \n												pushPos(-1),\n												poolCapacity(0),\n												curSize(0)\n			{\n				poolCapacity = capacity;\n				poolVec.reserve(poolCapacity);\n				T tempVal = 0;\n				for(int i=0; i<poolCapacity; ++i)\n				{\n					poolVec.push_back(tempVal);\n				}\n			}\n\n			~CircularQ()\n			{\n				for(int i=0; i < curSize; ++i)\n				{\n					//(poolVec[i])~T();\n				}\n			}\n\n			void addItemToPool(T item)\n			{\n				if(curSize >= poolCapacity)\n				{\n					// TODO : maintain name of the pool allocator \n					// for better error messages\n					cout << \"\\n Error : Tried to insert an item when the\";\n					cout << \" pool is full.\";\n					return;\n				}\n				pushPos = (++pushPos) % poolCapacity;\n				poolVec[pushPos] = item;\n				++curSize;\n				if(popPos == -1)\n				{\n					popPos = 0;\n				}\n			}\n\n			T getItemFromPool()\n			{\n				T retVal = 0;\n				if(curSize <= 0)\n				{\n					cout << \"\\n Error : Tried getting an item from empty pool allocator\";\n					return retVal;\n				}\n\n				retVal = poolVec[popPos];\n				popPos = (++popPos) % poolCapacity;\n				--curSize;\n				return retVal;\n			}\n\n			bool empty()\n			{\n				return curSize <= 0;\n			}\n\n			void printPoolHandlerQ()\n			{\n				cout << \"\\n Printing Pool Q :\";\n				for(int i=0, j=popPos; i < curSize; ++i, j=(++j % poolCapacity))\n				{\n					cout << poolVec[j] << \" \";\n				}\n				cout << \"\\n\";\n			}\n		private:\n			unsigned int poolCapacity;\n			std::vector<T> poolVec;\n			int pushPos; // points to the last item inserted\n			int popPos; // points to the element at the head of the queue\n			unsigned int curSize;\n\n		};\n	\n	private:\n		CircularQ<Data*> *availableDataNodesQ;\n		CircularQ<SlotIdSlotIndex*> *availableSlotIdIndexObjsQ;\n	public:\n		// test methods\n		void testCircularQ()\n		{\n			cout << \"\\n Testing pool circular Q\";\n\n			{\n				cout << \"\\n\\nTest1\";\n				CircularQ<int> test(1);\n				test.addItemToPool(1);\n				cout << \"\\nAdd item to pool \"; \n				cout << \"\\nFailed! Add item to pool \";\n				test.addItemToPool(2);\n				cout << \"\\nGet item from poool \" << test.getItemFromPool();\n				cout << \"\\nFailed! Get item from poool \" << test.getItemFromPool();\n			}\n\n			{\n				cout << \"\\n\\n Test2\";\n				CircularQ<int> test(5);\n				test.addItemToPool(1);\n				test.addItemToPool(2);\n				test.addItemToPool(3);\n				test.addItemToPool(4);\n				test.addItemToPool(5);\n				test.printPoolHandlerQ();\n				test.getItemFromPool();\n				test.printPoolHandlerQ();\n				test.addItemToPool(6);\n				test.printPoolHandlerQ();\n				test.getItemFromPool();\n				test.printPoolHandlerQ();\n				test.addItemToPool(7);\n				test.printPoolHandlerQ();\n				test.getItemFromPool();\n				test.printPoolHandlerQ();\n				test.addItemToPool(8);\n				test.printPoolHandlerQ();\n\n				while(!test.empty())\n				{\n					cout << test.getItemFromPool() << \" \";\n				}\n			}\n		}\n\n		void testCacheLRUPolicy()\n		{\n			cout << \"\\n Testing LRU policy\";\n			cout << \"\\n Serial testing for available slots\";\n			for(int i =0 ; i<2*NUM_SLOTS; ++i)\n			{\n				int slot = getAvailableSlot();\n				cout << \"\\n Slot \" << slot << \" used.\";\n				markSlotAsMRU(slot);\n				cout << \"\\n Slot \" << slot << \" marked as used.\";\n			}\n			cout << \"\\n Random testing for available slots\";\n			cout << \"\\n Marking random slots as used\";\n			for(int i =0 ; i<2*NUM_SLOTS; ++i)\n			{\n				int slot = rand() % NUM_SLOTS;\n				markSlotAsMRU(slot);\n				cout << \"\\n Slot \" << slot << \" marked as used.\";\n			}\n			cout << \"\\n Next available slot is \" << getAvailableSlot();\n		}\n\n		void testGetData(int numNodes)\n		{\n			Id n = 0;\n			const Data* node = 0;\n			cout << \"\\n Get Node \" << n;\n			node = getData(n);\n			if(node)\n			{\n				node->print(cout);\n			}\n			else\n			{\n				cout << \"\\n Null node for \" << n;\n			}\n\n			n = 1;\n			node = getData(n);\n			if(node)\n			{\n				node->print(cout);\n			}\n			else\n			{\n				cout << \"\\n Null node for \" << n;\n			}\n\n		}\n\n		void testReadOfDiskGraph(int numNodes)\n		{\n			ofstream out(\"printofdiskgraph\");\n			for(int i=0; i<numNodes; ++i)\n			{\n				const Data *node = getData(i);\n				if(node)\n				{\n					node->print(out);\n				}\n				else\n				{\n					cout << \"\\n Null node for \" << i;\n				}\n			}\n			out.close();\n		}\n		\n	};\n}\n",
			"settings":
			{
				"buffer_size": 25621,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 117.0,
		"last_filter": "Package Control: ins",
		"selected_items":
		[
			[
				"Package Control: ins",
				"Package Control: Install Package"
			],
			[
				"Package Control: in",
				"Package Control: Install Package"
			],
			[
				"Package Control: add",
				"Package Control: Add Repository"
			],
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"Package Control: inst",
				"Package Control: Install Package"
			],
			[
				"Package Control: int",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Install Package"
			]
		],
		"width": 458.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/shashank/project/source_ddg",
		"/home/shashank/project/source_ddg/include",
		"/home/shashank/project/source_ddg/include/ddg",
		"/home/shashank/project/source_ddg/include/ddg/analysis",
		"/home/shashank/project/source_ddg/tools",
		"/home/shashank/project/source_ddg/tools/reuse-analysis",
		"/home/shashank/project/source_ddg/tools/reuse-analysis/include",
		"/home/shashank/project/source_ddg/tools/reuse-analysis/src"
	],
	"file_history":
	[
		"/home/shashank/project/test_reuse_v2/mat_mul/asciiGraphPrint",
		"/home/shashank/project/test_reuse_v2/polaris_matmul/asciiGraphPrint",
		"/home/shashank/Desktop/scratch",
		"/home/shashank/project/test_reuse_v2/mat_mul/bfsWithQ",
		"/home/shashank/project/test_reuse_v2/mat_mul/bfsWithoutQ",
		"/home/shashank/project/source_ddg/build_dbg/tools/reuse-analysis/reuse-analysis-v2",
		"/home/shashank/project/source_ddg/include/ddg/analysis/DiskCache.hxx",
		"/home/shashank/project/source_ddg/build_dbg/test.cpp",
		"/home/shashank/project/source_ddg/build_dbg/oprofile_data/samples/operf.log",
		"/home/shashank/project/test_reuse_v2/mat_mul/bfsOut",
		"/home/shashank/project/test_reuse_v2/vec_add/bfsOut",
		"/home/shashank/project/test_reuse_v2/vec_add/cur_out",
		"/home/shashank/project/test_reuse_v2/vec_add/reuse_testgraphdump",
		"/home/shashank/project/source_ddg/include/ddg/analysis/DiskCDAG.hxx",
		"/home/shashank/project/source_ddg/include/ddg/analysis/Trace.hxx",
		"/home/shashank/project/test_reuse_v2/vec_add/reuse_testdiskgraph",
		"/home/shashank/project/source_ddg/include/ddg/analysis/LazyGraph.hxx",
		"/home/shashank/project/source_ddg/build_dbg/test.c",
		"/home/shashank/project/test_reuse_v2/mat_mul/out",
		"/home/shashank/project/test_reuse_v2/mat_mul/matmul.c",
		"/home/shashank/project/test_reuse_v2/vec_add/reuse_test.c",
		"/home/shashank/project/source_ddg/sftp-config.json",
		"/home/shashank/project/source_ddg/include/ddg/analysis/Ids.hxx",
		"/home/shashank/project/source_ddg/tools/region-dynamic-graph/region-dynamic-graph.hxx",
		"/home/shashank/project/source_ddg/lib/runtime/Runtime.cxx",
		"/home/shashank/project/source_ddg/lib/instrument/InstrumentDDG.cxx",
		"/home/shashank/project/source_ddg/lib/analysis/Ids.cxx",
		"/home/shashank/project/source_ddg/tools/region-dynamic-graph/region-dynamic-graph.cxx",
		"/home/shashank/Downloads/CMakeLists(1).txt",
		"/home/shashank/project/source_ddg/.git/COMMIT_EDITMSG",
		"/home/shashank/project/source_ddg/tools/dynamic-graph/dynamic-graph.cxx",
		"/home/shashank/project/source_ddg/include/ddg/analysis/DynamicGraph.hxx",
		"/home/shashank/project/source_ddg/lib/runtime/TraceCount.cxx",
		"/home/shashank/project/source_ddg/lib/analysis/Trace.cxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/LazyPartitionGraph.hxx",
		"/home/shashank/project/source_ddg/lib/analysis/DynamicGraph.cxx",
		"/home/shashank/project/source_ddg/tools/dynamic-graph/CMakeLists.txt",
		"/home/shashank/project/source_ddg/CMakeLists.txt",
		"/home/shashank/project/source_ddg/tools/region-dynamic-graph/CMakeLists.txt",
		"/home/shashank/project/source_ddg/.gitignore",
		"/home/shashank/project/source_ddg/tools/dynamic-graph/region-dynamic-graph.cxx",
		"/home/shashank/project/source_ddg/include/ddg/analysis/DynInstCounter.hxx",
		"/home/shashank/project/source_ddg/lib/analysis/DynInstCounter.cxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/TimestampVector.hxx",
		"/home/shashank/project/source_ddg/lib/instrument/Visitors.cxx",
		"/home/shashank/project/source_ddg/include/ddg/instrument/Visitors.hxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/TimestampVector.cxx",
		"/home/shashank/project/source_ddg/tools/ddg-vect/ddg-vect-rt.cxx",
		"/home/shashank/project/source_ddg/include/ddg/common/types.hxx",
		"/home/shashank/tmp/test/trace.txt",
		"/home/shashank/softwares/gcc-4.6.1/libjava/prims.cc",
		"/home/shashank/softwares/mpc-1.0.2/INSTALL",
		"/home/shashank/softwares/llvm-3.1.src/LLVMBuild.txt",
		"/home/shashank/softwares/gmp-4.3.2/INSTALL",
		"/home/shashank/softwares/mpfr-3.1.2/INSTALL",
		"/home/shashank/softwares/boost_1_49_0/bootstrap.log",
		"/home/shashank/softwares/gcc-4.6.1/INSTALL/README",
		"/home/shashank/README.txt",
		"/tmp/evince-1925/image.AUASPX.png",
		"/home/shashank/lisp_project/tests/eval/temptest",
		"/home/shashank/lisp_project/README.txt",
		"/home/shashank/lisp_project/.git/COMMIT_EDITMSG",
		"/home/shashank/lisp_project/tests/eval/classtestneg",
		"/home/shashank/lisp_project/tests/eval/postc",
		"/home/shashank/lisp_project/tests/testcase_list.txt",
		"/home/shashank/lisp_project/tests/eval/rajtest",
		"/home/shashank/lisp_project/tests/eval/classtestpos",
		"/home/shashank/lisp_project/tests/eval/sorttest",
		"/home/shashank/lisp_project/tests/parser/testcase_list-1.txt",
		"/home/shashank/lisp_project/tests/test6.expected",
		"/home/shashank/lisp_project/src/OutputHandler.java",
		"/home/shashank/lisp_project/tests/eval/negtc",
		"/home/shashank/lisp_project/src/Parser.java",
		"/home/shashank/lisp_project/src/Lex.java",
		"/home/shashank/lisp_project/tests/parser/test1",
		"/home/shashank/lisp_project/src/MyInt.java",
		"/home/shashank/lisp_project/tests/parser/listsTest",
		"/home/shashank/lisp_project/tests/parser/stagetest",
		"/home/shashank/lisp_project/src/Token.java",
		"/home/shashank/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/shashank/lisp_project/bin/.gitignore",
		"/home/shashank/lisp_project/Runfile",
		"/home/shashank/lisp_project/tests/parser/pos_tests",
		"/home/shashank/lisp_project/tests/parser/pos_tests2",
		"/home/shashank/lisp_project/tests/parser/testcase_list.txt",
		"/home/shashank/lisp_project/tests/test1.expected",
		"/home/shashank/lisp_project/out",
		"/home/shashank/lisp_project/tests/test1",
		"/home/shashank/lisp_project/tests/parser/test5",
		"/home/shashank/lisp_project/tests/invalid1",
		"/home/shashank/lisp_project/src/LispIntException.java",
		"/home/shashank/.config/sublime-text-3/Packages/navigationHistory.py",
		"/home/shashank/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/shashank/.config/sublime-text-3/Packages/User/Package Control.sublime-settings",
		"/home/shashank/lisp_project/tests/parser/test4",
		"/home/shashank/lisp_project/tests/invalid2",
		"/home/shashank/lisp_project/tests/invalid3",
		"/home/shashank/lisp_project/tests/invalid4",
		"/home/shashank/lisp_project/tests/parser/test2",
		"/home/shashank/lisp_project/tests/test8",
		"/home/shashank/lisp_project/Makefile",
		"/home/shashank/lisp_project/tests/parser/test3",
		"/home/shashank/lisp_project/tests/lex/test1.txt",
		"/home/shashank/lisp_project/tests/test7",
		"/home/shashank/lisp_project/.git/MERGE_MSG",
		"/home/shashank/lisp_project_c/tests/lex/test1.txt",
		"/home/shashank/Downloads/CMakeLists.txt",
		"/home/shashank/Desktop/singhsha.txt",
		"/home/shashank/lisp_project/.tags_sorted_by_file",
		"/home/shashank/sftp-config.json",
		"/home/shashank/lisp_project_c/Makefile",
		"/home/shashank/lisp_project/src/Debug.java",
		"/tmp/CMakeLists.txt",
		"/home/shashank/.cache/.fr-Vf8rQV/eclipse/eclipse.ini",
		"/home/shashank/.config/sublime-text-3/Packages/User/subclim_plugin.py",
		"/home/shashank/remote/jlex-1.2.6/JLex/CMakeNfa.java",
		"/home/shashank/remote/jlex-1.2.6/sootOutput/JLex.CMakeNfa.jimple",
		"/home/shashank/lisp_project/.git/info/exclude",
		"/home/shashank/remote/proj4/MyTransform.jva",
		"/home/shashank/remote/proj4/jlex-1.2.6/test.txt",
		"/home/shashank/Downloads/cg.f",
		"/home/shashank/remote/cta/MyTransform.java~",
		"/home/shashank/remote/proj3/MyTransform.java",
		"/home/shashank/lisp_project/proj_java/invalid1",
		"/home/shashank/lisp_interpreter_in_java-master/Makefile",
		"/home/shashank/lisp_interpreter_in_java-master/manifest.txt",
		"/home/shashank/lisp_project/proj_java/Makefile",
		"/home/shashank/lisp_project/proj_java/test1"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			"",
			"region-dynamic-graph.cxx",
			"region-dynamic-graph.hxx",
			"*.cxx,*.hxx",
			"*.cxx;*.hxx",
			"",
			"/home/shashank/lisp_project/src/",
			"/home/shashank/lisp_project/src/Lex.java",
			"/home/shashank/lisp_project/src/Parser.java",
			"/home/shashank/lisp_project/src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"graphinasci",
			"asciigra",
			"readNodefrombin",
			"readBlockFromFile",
			"succscache",
			"updateGraphWithSuccessorInfo",
			"succsca",
			"succsc",
			"cleanup",
			"succsCa",
			"281201",
			"printDiskGraph",
			"test",
			"availableDataNodesQ.",
			"availableSlotIdIndexObjsQ.",
			"availableDataNodesQ",
			"availableSlotIdIndexObjsQ",
			"PoolHandlerCircularQ",
			"lrucache = new",
			"lruCac",
			"lruCace",
			"diskcache",
			"diskcace",
			"unmarkNode",
			"perf",
			"numOfBytesFornodeMarkerBitSet",
			"getFir",
			"readBlockInSlot",
			"availableDataNodesQ",
			"invalidateslot",
			"applyLRUPolicy",
			"getAvailableSlot",
			"vector<Id>",
			"readBlockin",
			"done",
			"slotIndex",
			"readBlockinslo",
			"getAvailableDataNode",
			"availableDataNodesQ",
			"readBlockInSlot",
			"readBl",
			"isInCache",
			"availableDataNodesQ",
			"availableDataNodesQ.pop_front()",
			"availableDataNodesQ",
			"readBlockInSlot",
			"setVa",
			"dataIdToSlotMap",
			"availableSlotIdIndexObjsQ",
			"dataIdToSlotMap",
			"SlotIdSlotIndex",
			"readBlockForDataIndexing",
			"createDataIndex",
			"succsCa",
			"createDataIndex",
			"availableDataNodesQ",
			"availableSlotIdIndexObjs",
			"availableDataNodesQ",
			"readBlockInSlot",
			"starting vertex",
			"new .*\\[",
			"new .*/[",
			"new .*[",
			"new ",
			"new",
			"delete",
			"prev",
			"perf",
			"Number of nodes processed",
			"NUM_S",
			"availableDataNodesQ",
			"erase",
			"SLOT_ITERATOR",
			"erase",
			"1024",
			"nUM_S",
			"isBitSet",
			"unsetBitInBitset",
			"unmarkNode",
			"unsetBitInBitset",
			"unmarkNode",
			"perf",
			"getFirstReadyNode",
			"unmarkAllNodes",
			"unmark",
			"unmarkAllNodes",
			"100",
			"bfsOutput",
			"NUM_SLOTS",
			"remove",
			"writeToStreamInBinary",
			"update",
			"print(c",
			"readBlockFromFile",
			"readNodeFromBinaryFile",
			"remove",
			"readNodeFromB",
			"writeToStreamInBinary",
			"writetostream",
			"readNodeFromASCIIFile",
			"readNodeFromAsc",
			"writetos",
			"readNodefromasci",
			"readNodefrom",
			"writetostre",
			"initFileHandle",
			"writeToStream",
			".write",
			"lruCache",
			"LRUCache",
			"lruCache",
			"LRUCache",
			"lruCache",
			"LRUCache",
			"lruCache",
			"LRUCache",
			"lruCache",
			"LRUCache",
			"lruCache",
			"initLRUCacheForDiskGraph",
			"initLr",
			"datac",
			"dataIdBlockRangeList",
			"readDataIndexFile",
			"numNodes",
			"generateGra",
			"CHILDCOUNT",
			"NCOUNT"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"CircularQ",
			"RegionDynamicGraph",
			"ddg_region_end",
			"ddg_region_begin",
			"regionEndFn",
			"regionBeginFn",
			"endRegionFn",
			"beginRegionFn",
			"c_isspace",
			"out.dump",
			""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "include/ddg/analysis/DiskCache.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25621,
						"regions":
						{
						},
						"selection":
						[
							[
								1327,
								1327
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"incomplete_sync": null,
							"remote_loading": false,
							"sftp_duplicate_views": 0,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 684.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "include/ddg/analysis/DiskCDAG.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 46900,
						"regions":
						{
						},
						"selection":
						[
							[
								9497,
								9497
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"incomplete_sync": null,
							"remote_loading": false,
							"sftp_duplicate_views": 0,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 6938.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "tools/reuse-analysis/include/ReadCDAG.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2960,
						"regions":
						{
						},
						"selection":
						[
							[
								849,
								860
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 741.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		},
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "include/ddg/analysis/DiskCache.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25621,
						"regions":
						{
						},
						"selection":
						[
							[
								25621,
								25621
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"incomplete_sync": null,
							"remote_loading": false,
							"sftp_duplicate_views": 0,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 19893.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "include/ddg/analysis/DiskCDAG.hxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 46900,
						"regions":
						{
						},
						"selection":
						[
							[
								26474,
								26474
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"incomplete_sync": null,
							"remote_loading": false,
							"sftp_duplicate_views": 0,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 19326.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "tools/reuse-analysis/src/Main.cxx",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4932,
						"regions":
						{
						},
						"selection":
						[
							[
								666,
								666
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 4,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25621,
						"regions":
						{
						},
						"selection":
						[
							[
								25621,
								25621
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 18952.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 27.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.488950276243,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 118.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.sftp":
	{
		"height": 112.0
	},
	"pinned_build_system": "",
	"project": "source_ddg.sublime-project",
	"replace":
	{
		"height": 50.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"traceno",
				"lib/runtime/TraceCount.cxx"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 226.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
